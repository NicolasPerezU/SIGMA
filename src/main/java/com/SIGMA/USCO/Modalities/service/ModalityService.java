package com.SIGMA.USCO.Modalities.service;

import com.SIGMA.USCO.Modalities.Entity.*;
import com.SIGMA.USCO.Modalities.Entity.enums.*;
import com.SIGMA.USCO.Modalities.Repository.*;
import com.SIGMA.USCO.Modalities.dto.*;
import com.SIGMA.USCO.Modalities.dto.response.*;
import com.SIGMA.USCO.Users.Entity.*;
import com.SIGMA.USCO.Users.Entity.enums.ProgramRole;
import com.SIGMA.USCO.Users.repository.ProgramAuthorityRepository;
import com.SIGMA.USCO.Users.repository.UserRepository;
import com.SIGMA.USCO.academic.entity.*;
import com.SIGMA.USCO.academic.repository.*;
import com.SIGMA.USCO.documents.dto.*;
import com.SIGMA.USCO.documents.entity.*;
import com.SIGMA.USCO.documents.repository.*;
import com.SIGMA.USCO.notifications.entity.enums.NotificationRecipientType;
import com.SIGMA.USCO.notifications.event.*;
import com.SIGMA.USCO.notifications.publisher.NotificationEventPublisher;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ModalityService {

    private final DegreeModalityRepository degreeModalityRepository;
    private final ModalityRequirementsRepository modalityRequirementsRepository;
    private final RequiredDocumentRepository requiredDocumentRepository;
    private final UserRepository userRepository;
    private final StudentProfileRepository studentProfileRepository;
    private final StudentModalityRepository studentModalityRepository;
    private final StudentModalityMemberRepository studentModalityMemberRepository;
    private final StudentDocumentRepository studentDocumentRepository;
    private final ModalityProcessStatusHistoryRepository historyRepository;
    private final StudentDocumentStatusHistoryRepository documentHistoryRepository;
    private final NotificationEventPublisher notificationEventPublisher;
    private final FacultyRepository facultyRepository;
    private final ProgramDegreeModalityRepository programDegreeModalityRepository;
    private final ProgramAuthorityRepository programAuthorityRepository;
    private final DefenseExaminerRepository defenseExaminerRepository;
    private final ExaminerEvaluationRepository examinerEvaluationRepository;


    @Value("${file.upload-dir}")
    private String uploadDir;


    public DegreeModality createModality(ModalityDTO request) {

        if (request.getName() == null || request.getName().isBlank()) {
            throw new IllegalArgumentException("El nombre de la modalidad es obligatorio.");
        }

        if (request.getFacultyId() == null) {
            throw new IllegalArgumentException("La facultad es obligatoria.");
        }

        Faculty faculty = facultyRepository.findById(request.getFacultyId())
                .orElseThrow(() ->
                        new IllegalArgumentException("La facultad no existe.")
                );

        if (degreeModalityRepository.existsByNameIgnoreCaseAndFacultyId(request.getName(), faculty.getId())) {
            throw new IllegalArgumentException("Ya existe una modalidad con ese nombre en esta facultad.");
        }

        DegreeModality modality = DegreeModality.builder()
                .name(request.getName().toUpperCase())
                .description(request.getDescription())
                .status(ModalityStatus.ACTIVE)
                .faculty(faculty)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        return degreeModalityRepository.save(modality);
    }
    public ResponseEntity<?> updateModality(Long modalityId, ModalityDTO request) {

        if (!degreeModalityRepository.existsById(modalityId)) {
            return ResponseEntity.badRequest().body("La modalidad con ID " + modalityId + " no existe.");
        }

        DegreeModality modality = degreeModalityRepository.findById(modalityId).orElseThrow();

        Faculty faculty = facultyRepository.findById(request.getFacultyId())
                .orElseThrow(() ->
                        new IllegalArgumentException("La facultad no existe.")
                );

        modality.setFaculty(faculty);
        modality.setName(request.getName());
        modality.setDescription(request.getDescription());
        modality.setStatus(request.getStatus());
        modality.setUpdatedAt(LocalDateTime.now());

        degreeModalityRepository.save(modality);

        return ResponseEntity.ok("Modalidad actualizada exitosamente");
    }
    public ResponseEntity<?> desactiveModality(Long modalityId) {

        if (!degreeModalityRepository.existsById(modalityId)) {
            return ResponseEntity.badRequest().body("La modalidad con ID " + modalityId + " no existe.");
        }

        DegreeModality modality = degreeModalityRepository.findById(modalityId).orElseThrow();

        modality.setStatus(ModalityStatus.INACTIVE);
        modality.setUpdatedAt(LocalDateTime.now());

        degreeModalityRepository.save(modality);

        return ResponseEntity.ok("Modalidad desactivada exitosamente");
    }
    public void createModalityRequirements(Long modalityId, List<RequirementDTO> requirements) {

        if (requirements == null || requirements.isEmpty()) {
            throw new IllegalArgumentException("La lista de requisitos no puede estar vacía.");
        }

        DegreeModality modality = degreeModalityRepository.findById(modalityId)
                .orElseThrow(() -> new IllegalArgumentException("La modalidad con ID " + modalityId + " no existe."));

        for (RequirementDTO req : requirements) {

            if (req.getRequirementName() == null || req.getRequirementName().isBlank()) {throw new IllegalArgumentException("El nombre del requisito es obligatorio.");}

            if (req.getRuleType() == null) {
                throw new IllegalArgumentException("El tipo de regla es obligatorio para el requisito: " + req.getRequirementName());
            }

            if (req.getExpectedValue() == null || req.getExpectedValue().isBlank()) {
                throw new IllegalArgumentException("El valor esperado es obligatorio para el requisito: " + req.getRequirementName());
            }

            ModalityRequirements requirement = ModalityRequirements.builder()
                    .modality(modality)
                    .requirementName(req.getRequirementName())
                    .description(req.getDescription())
                    .ruleType(req.getRuleType())
                    .expectedValue(req.getExpectedValue())
                    .active(true)
                    .createdAt(LocalDateTime.now())
                    .updatedAt(LocalDateTime.now())
                    .build();

            modalityRequirementsRepository.save(requirement);
        }
    }

    public void updateModalityRequirement(Long modalityId, Long requirementId, RequirementDTO req) {

        DegreeModality modality = degreeModalityRepository.findById(modalityId)
                .orElseThrow(() ->
                        new IllegalArgumentException("La modalidad con ID " + modalityId + " no existe.")
                );

        ModalityRequirements requirement = modalityRequirementsRepository.findById(requirementId)
                .orElseThrow(() ->
                        new IllegalArgumentException("El requisito con ID " + requirementId + " no existe.")
                );

        if (!requirement.getModality().getId().equals(modality.getId())) {
            throw new IllegalArgumentException(
                    "El requisito no pertenece a la modalidad indicada."
            );
        }



        if (req.getRequirementName() != null) {
            if (req.getRequirementName().isBlank()) {
                throw new IllegalArgumentException("El nombre del requisito no puede estar vacío.");
            }
            requirement.setRequirementName(req.getRequirementName());
        }

        if (req.getDescription() != null) {
            requirement.setDescription(req.getDescription());
        }

        if (req.getRuleType() != null) {
            requirement.setRuleType(req.getRuleType());
        }

        if (req.getExpectedValue() != null) {
            if (req.getExpectedValue().isBlank()) {
                throw new IllegalArgumentException("El valor esperado no puede estar vacío.");
            }
            requirement.setExpectedValue(req.getExpectedValue());
        }



        requirement.setUpdatedAt(LocalDateTime.now());

        modalityRequirementsRepository.save(requirement);
    }

    public ResponseEntity<List<RequirementDTO>> getModalityRequirements(Long modalityId, Boolean active) {

        if (!degreeModalityRepository.existsById(modalityId)) {
            return ResponseEntity.badRequest().body(List.of());
        }

        List<ModalityRequirements> requirements;

        if (active != null) {
            requirements = modalityRequirementsRepository.findByModalityIdAndActive(modalityId, active);
        } else {
            requirements = modalityRequirementsRepository.findByModalityId(modalityId);
        }

        List<RequirementDTO> response = requirements.stream()
                .map(r -> RequirementDTO.builder()
                        .id(r.getId())
                        .requirementName(r.getRequirementName())
                        .description(r.getDescription())
                        .ruleType(r.getRuleType())
                        .expectedValue(r.getExpectedValue())
                        .active(r.isActive())
                        .build())
                .toList();

        return ResponseEntity.ok(response);
    }
    public ResponseEntity<?> deleteRequirement(Long requirementId) {

        ModalityRequirements requirement = modalityRequirementsRepository.findById(requirementId)
                .orElseThrow(() -> new RuntimeException("Requisito no encontrado"));

        requirement.setActive(false);
        requirement.setUpdatedAt(LocalDateTime.now());

        modalityRequirementsRepository.save(requirement);

        return ResponseEntity.ok("Requisito desactivado correctamente");
    }
    public ResponseEntity<List<ModalityDTO>> getAllModalities() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentProfile profile = studentProfileRepository.findByUserId(user.getId())
                .orElseThrow(() -> new RuntimeException("Perfil académico no encontrado"));

        Long userProgramId = profile.getAcademicProgram().getId();

        List<DegreeModality> modalities = degreeModalityRepository.findByStatus(ModalityStatus.ACTIVE);

        List<ModalityDTO> modalityDTOs = modalities.stream().map(mod -> {

            Optional<ProgramDegreeModality> pdmOpt = programDegreeModalityRepository
                    .findByAcademicProgramIdAndDegreeModalityIdAndActiveTrue(userProgramId, mod.getId());

            Long creditsRequired = null;
            if (pdmOpt.isPresent() && pdmOpt.get().getCreditsRequired() != null) {
                creditsRequired = pdmOpt.get().getCreditsRequired();
            }

            return ModalityDTO.builder()
                    .id(mod.getId())
                    .name(mod.getName())
                    .facultyName(mod.getFaculty().getName())
                    .description(mod.getDescription())
                    .facultyId(mod.getFaculty().getId())
                    .status(mod.getStatus())
                    .requiredCredits(creditsRequired != null ? creditsRequired.doubleValue() : null)
                    .build();

        }).toList();

        return ResponseEntity.ok(modalityDTOs);
    }

    public ResponseEntity<?> getModalityDetail(Long modalityId) {

        if (!degreeModalityRepository.existsById(modalityId)) {
            return ResponseEntity.badRequest().body("La modalidad con ID " + modalityId + " no existe.");
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentProfile profile = studentProfileRepository.findByUserId(user.getId())
                .orElseThrow(() -> new RuntimeException("Perfil académico no encontrado"));

        Long userProgramId = profile.getAcademicProgram().getId();


        Optional<ProgramDegreeModality> pdmOpt = programDegreeModalityRepository
                .findByAcademicProgramIdAndDegreeModalityIdAndActiveTrue(userProgramId, modalityId);

        Long creditsRequired = null;
        if (pdmOpt.isPresent() && pdmOpt.get().getCreditsRequired() != null) {
            creditsRequired = pdmOpt.get().getCreditsRequired();
        }

        var requirements = modalityRequirementsRepository.findByModalityIdAndActiveTrue(modalityId)
                .stream()
                .map(req -> RequirementDTO.builder()
                        .id(req.getId())
                        .requirementName(req.getRequirementName())
                        .description(req.getDescription())
                        .expectedValue(req.getExpectedValue())
                        .ruleType(req.getRuleType())
                        .build())
                .toList();

        var documents = requiredDocumentRepository
                .findByModalityIdAndActiveTrueAndDocumentType(modalityId, DocumentType.MANDATORY)
                .stream()
                .map(doc -> RequiredDocumentDTO.builder()
                        .id(doc.getId())
                        .modalityId(modalityId)
                        .documentName(doc.getDocumentName())
                        .description(doc.getDescription())
                        .allowedFormat(doc.getAllowedFormat())
                        .maxFileSizeMB(doc.getMaxFileSizeMB())
                        .documentType(doc.getDocumentType())
                        .build())
                .toList();

        DegreeModality modality = degreeModalityRepository.findById(modalityId).orElseThrow();

        ModalityDTO modalityDetail = ModalityDTO.builder()
                .id(modalityId)
                .name(modality.getName())
                .description(modality.getDescription())
                .facultyId(modality.getFaculty().getId())
                .facultyName(modality.getFaculty().getName())
                .requiredCredits(creditsRequired != null ? creditsRequired.doubleValue() : null)
                .requirements(requirements)
                .documents(documents)
                .build();

        return ResponseEntity.ok(modalityDetail);

    }

    @Transactional
    public ResponseEntity<?> startStudentModalityIndividual(Long modalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentProfile profile = studentProfileRepository.findByUserId(student.getId())
                .orElseThrow(() -> new RuntimeException("Debe completar su perfil académico antes de seleccionar una modalidad"));


        DegreeModality modality = degreeModalityRepository.findById(modalityId)
                .orElseThrow(() -> new RuntimeException("La modalidad con ID " + modalityId + " no existe"));


        ProgramDegreeModality programDegreeModality =
                programDegreeModalityRepository.findByAcademicProgramIdAndDegreeModalityIdAndActiveTrue(profile.getAcademicProgram().getId(), modalityId)
                        .orElseThrow(() -> new RuntimeException("La modalidad no está habilitada para tu programa académico"));



        // Verificar si el estudiante tiene modalidades activas (en proceso)

        List<ModalityProcessStatus> finalizedStatuses = List.of(
                ModalityProcessStatus.MODALITY_CLOSED,
                ModalityProcessStatus.MODALITY_CANCELLED,
                ModalityProcessStatus.GRADED_FAILED
        );

        // Obtener todas las modalidades del estudiante como miembro activo
        List<StudentModalityMember> activeMembers = studentModalityMemberRepository.findByStudentIdAndStatus(
                student.getId(),
                MemberStatus.ACTIVE
        );

        // Verificar si alguna de esas modalidades NO está finalizada
        for (StudentModalityMember member : activeMembers) {
            ModalityProcessStatus currentStatus = member.getStudentModality().getStatus();
            if (!finalizedStatuses.contains(currentStatus)) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "eligible", false,
                                "message", "Ya tienes una modalidad de grado en curso. No puedes iniciar otra."
                        )
                );
            }
        }

        // Verificar si el estudiante tiene una modalidad CERRADA (MODALITY_CLOSED)
        // Si tiene una modalidad cerrada, NO puede volver a iniciar la MISMA modalidad
        List<StudentModality> closedModalities = studentModalityRepository.findByLeaderIdAndStatus(
                student.getId(),
                ModalityProcessStatus.MODALITY_CLOSED
        );

        for (StudentModality closedModality : closedModalities) {
            if (closedModality.getProgramDegreeModality().getDegreeModality().getId().equals(modalityId)) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "eligible", false,
                                "message", "No puedes volver a iniciar esta modalidad porque ya fue cerrada anteriormente. Debes seleccionar una modalidad diferente."
                        )
                );
            }
        }



        List<ModalityRequirements> requirements = modalityRequirementsRepository.findByModalityIdAndActiveTrue(modalityId);

        List<ValidationItemDTO> results = new ArrayList<>();
        boolean allValid = true;

        for (ModalityRequirements req : requirements) {

            if (req.getRuleType() != RuleType.NUMERIC) {
                continue;
            }

            boolean fulfilled = true;
            String studentValue = "";


            if (req.getRequirementName().toLowerCase().contains("crédito")) {

                double percentageRequired = Double.parseDouble(req.getExpectedValue());
                long totalCredits = profile.getAcademicProgram().getTotalCredits();
                long requiredCredits = Math.round(totalCredits * percentageRequired);

                fulfilled = profile.getApprovedCredits() >= requiredCredits;
                studentValue = profile.getApprovedCredits() + " / " + requiredCredits;
            }


            if (req.getRequirementName().toLowerCase().contains("promedio")) {

                fulfilled = profile.getGpa() >= Double.parseDouble(req.getExpectedValue());
                studentValue = String.valueOf(profile.getGpa());
            }

            results.add(
                    ValidationItemDTO.builder()
                            .requirementName(req.getRequirementName())
                            .expectedValue(req.getExpectedValue())
                            .studentValue(studentValue)
                            .fulfilled(fulfilled)
                            .build()
            );

            if (!fulfilled) {
                allValid = false;
            }
        }

        if (!allValid) {
            return ResponseEntity.badRequest().body(
                    ValidationResultDTO.builder()
                            .eligible(false)
                            .results(results)
                            .message("No cumples los requisitos académicos para esta modalidad")
                            .build()
            );
        }



        StudentModality studentModality = StudentModality.builder()
                .leader(student)
                .modalityType(ModalityType.INDIVIDUAL)
                .academicProgram(profile.getAcademicProgram())
                .programDegreeModality(programDegreeModality)
                .status(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD)
                .selectionDate(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        studentModalityRepository.save(studentModality);


        StudentModalityMember member = StudentModalityMember.builder()
                .studentModality(studentModality)
                .student(student)
                .isLeader(true)
                .status(MemberStatus.ACTIVE)
                .joinedAt(LocalDateTime.now())
                .build();

        studentModalityMemberRepository.save(member);



        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD)
                        .changeDate(LocalDateTime.now())
                        .responsible(student)
                        .observations("Modalidad individual iniciada por el estudiante")
                        .build()
        );



        notificationEventPublisher.publish(
                new StudentModalityStarted(
                        studentModality.getId(),
                        student.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "eligible", true,
                        "studentModalityId", studentModality.getId(),
                        "studentModalityName", modality.getName(),
                        "modalityType", "INDIVIDUAL",
                        "message", "Modalidad iniciada correctamente. Puedes subir los documentos."
                )
        );
    }
    public ResponseEntity<?> uploadRequiredDocument(Long studentModalityId, Long requiredDocumentId, MultipartFile file) throws IOException {

        if (file == null || file.isEmpty()) {
            return ResponseEntity.badRequest().body("El archivo es obligatorio");
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad del estudiante no encontrada"));


        boolean isActiveMember = studentModalityMemberRepository.isActiveMember(
                studentModalityId,
                student.getId()
        );

        if (!isActiveMember) {
            return ResponseEntity.status(403).body("No autorizado para subir documentos a esta modalidad");
        }

        RequiredDocument requiredDocument = requiredDocumentRepository.findById(requiredDocumentId)
                .orElseThrow(() -> new RuntimeException("Documento requerido no existe"));

        DegreeModality modality = studentModality.getProgramDegreeModality().getDegreeModality();

        if (!requiredDocument.getModality().getId().equals(modality.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("El documento no pertenece a la modalidad seleccionada");
        }

        String originalFilename = file.getOriginalFilename();
        String extension = originalFilename.substring(originalFilename.lastIndexOf('.') + 1).toLowerCase();

        if (requiredDocument.getAllowedFormat() != null &&
                !requiredDocument.getAllowedFormat().toLowerCase().contains(extension)) {
            return ResponseEntity.badRequest().body("Formato de archivo no permitido");
        }

        if (requiredDocument.getMaxFileSizeMB() != null &&
                file.getSize() > requiredDocument.getMaxFileSizeMB() * 1024L * 1024L) {
            return ResponseEntity.badRequest().body("El archivo supera el tamaño permitido");
        }


        String modalityFolder = modality.getName()
                .replaceAll("[^a-zA-Z0-9]", "_");

        String studentFolder = student.getName() + student.getLastName() + "_" +
                student.getLastName() + "_" +
                student.getId();

        Path basePath = Paths.get(
                uploadDir,
                modalityFolder,
                studentFolder
        );

        Files.createDirectories(basePath);

        String finalFileName = UUID.randomUUID() + "_" + originalFilename;
        Path fullPath = basePath.resolve(finalFileName);

        Files.copy(file.getInputStream(), fullPath, StandardCopyOption.REPLACE_EXISTING);


        StudentDocument studentDocument = studentDocumentRepository
                .findByStudentModalityIdAndDocumentConfigId(studentModalityId, requiredDocumentId)
                .orElse(
                        StudentDocument.builder()
                                .studentModality(studentModality)
                                .documentConfig(requiredDocument)
                                .build()
                );

        studentDocument.setFileName(originalFilename);
        studentDocument.setFilePath(fullPath.toString());
        studentDocument.setStatus(DocumentStatus.PENDING);
        studentDocument.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(studentDocument);

        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(studentDocument)
                        .status(DocumentStatus.PENDING)
                        .changeDate(LocalDateTime.now())
                        .responsible(student)
                        .observations("Documento cargado o actualizado por el estudiante")
                        .build()
        );

        notificationEventPublisher.publish(
                new StudentDocumentUpdatedEvent(studentModality.getId(), studentDocument.getId(), student.getId()
                )
        );

        // ========== VERIFICAR SI TODOS LOS DOCUMENTOS MANDATORY HAN SIDO SUBIDOS ==========
        // Si todos los documentos obligatorios están subidos, cambiar el estado de la modalidad
        checkAndUpdateModalityStatusIfAllMandatoryDocsUploaded(studentModality, student);

        return ResponseEntity.ok(
                Map.of(
                        "message", "Documento subido correctamente",
                        "path", fullPath.toString()
                )
        );
    }


    private void checkAndUpdateModalityStatusIfAllMandatoryDocsUploaded(StudentModality studentModality, User responsibleUser) {

        // Solo aplicar esta lógica si la modalidad está en estado MODALITY_SELECTED
        if (studentModality.getStatus() != ModalityProcessStatus.MODALITY_SELECTED) {
            return;
        }

        Long modalityId = studentModality.getProgramDegreeModality().getDegreeModality().getId();

        // Obtener todos los documentos MANDATORY requeridos para esta modalidad
        List<RequiredDocument> mandatoryDocuments = requiredDocumentRepository
                .findByModalityIdAndActiveTrueAndDocumentType(modalityId, DocumentType.MANDATORY);

        if (mandatoryDocuments.isEmpty()) {
            return; // No hay documentos obligatorios configurados
        }

        // Obtener todos los documentos subidos por el estudiante
        List<StudentDocument> uploadedDocuments = studentDocumentRepository
                .findByStudentModalityId(studentModality.getId());

        Set<Long> uploadedDocumentIds = uploadedDocuments.stream()
                .map(doc -> doc.getDocumentConfig().getId())
                .collect(Collectors.toSet());

        // Verificar si TODOS los documentos MANDATORY han sido subidos
        boolean allMandatoryDocsUploaded = mandatoryDocuments.stream()
                .allMatch(doc -> uploadedDocumentIds.contains(doc.getId()));

        if (allMandatoryDocsUploaded) {
            // Cambiar el estado de la modalidad a UNDER_REVIEW_PROGRAM_HEAD
            studentModality.setStatus(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD);
            studentModality.setUpdatedAt(LocalDateTime.now());
            studentModalityRepository.save(studentModality);

            // Registrar en el historial
            historyRepository.save(
                    ModalityProcessStatusHistory.builder()
                            .studentModality(studentModality)
                            .status(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD)
                            .changeDate(LocalDateTime.now())
                            .responsible(responsibleUser)
                            .observations("Todos los documentos obligatorios (MANDATORY) han sido subidos. " +
                                         "La modalidad pasa automáticamente a revisión del jefe de programa.")
                            .build()
            );

            log.info("Modalidad {} cambió automáticamente a UNDER_REVIEW_PROGRAM_HEAD - Todos los documentos MANDATORY subidos",
                    studentModality.getId());
        }
    }
    public ResponseEntity<?> validateAllDocumentsUploaded(Long studentModalityId) {

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        Long modalityId = studentModality.getProgramDegreeModality().getDegreeModality().getId();

        List<RequiredDocument> requiredDocuments =
                requiredDocumentRepository.findByModalityIdAndActiveTrue(modalityId);

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository.findByStudentModalityId(studentModalityId);

        Set<Long> uploadedIds = uploadedDocuments.stream()
                .map(d -> d.getDocumentConfig().getId())
                .collect(Collectors.toSet());

        List<String> missingDocuments = requiredDocuments.stream()
                .filter(doc -> doc.getDocumentType() == DocumentType.MANDATORY)
                .filter(doc -> !uploadedIds.contains(doc.getId()))
                .map(RequiredDocument::getDocumentName)
                .toList();

        boolean allUploaded = missingDocuments.isEmpty();

        return ResponseEntity.ok(
                Map.of(
                        "canContinue", allUploaded,
                        "missingDocuments", missingDocuments
                )
        );
    }

    public ResponseEntity<?> getAvailableDocumentsForStudent() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        Optional<StudentModality> studentModalityOpt = studentModalityRepository
                .findTopByStudentIdOrderByUpdatedAtDesc(student.getId());

        if (studentModalityOpt.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of(
                            "success", false,
                            "message", "No se encontró una modalidad asociada al estudiante"
                    ));
        }

        StudentModality studentModality = studentModalityOpt.get();
        Long studentModalityId = studentModality.getId();
        Long modalityId = studentModality.getProgramDegreeModality().getDegreeModality().getId();


        List<RequiredDocument> mandatoryDocuments = requiredDocumentRepository
                .findByModalityIdAndActiveTrueAndDocumentType(modalityId, DocumentType.MANDATORY);


        List<StudentDocument> uploadedDocuments = studentDocumentRepository
                .findByStudentModalityId(studentModalityId);

        Set<Long> uploadedDocumentIds = uploadedDocuments.stream()
                .map(d -> d.getDocumentConfig().getId())
                .collect(Collectors.toSet());


        List<String> missingMandatoryDocs = mandatoryDocuments.stream()
                .filter(doc -> !uploadedDocumentIds.contains(doc.getId()))
                .map(RequiredDocument::getDocumentName)
                .toList();

        if (!missingMandatoryDocs.isEmpty()) {


            List<RequiredDocument> mandatoryOnly = mandatoryDocuments;

            List<Map<String, Object>> documentList = mandatoryOnly.stream()
                    .map(requiredDoc -> {
                        Map<String, Object> docInfo = new HashMap<>();
                        docInfo.put("requiredDocumentId", requiredDoc.getId());
                        docInfo.put("documentName", requiredDoc.getDocumentName());
                        docInfo.put("description", requiredDoc.getDescription());
                        docInfo.put("documentType", requiredDoc.getDocumentType());
                        docInfo.put("allowedFormat", requiredDoc.getAllowedFormat());
                        docInfo.put("maxFileSizeMB", requiredDoc.getMaxFileSizeMB());
                        docInfo.put("uploaded", false);
                        return docInfo;
                    })
                    .toList();

            return ResponseEntity.ok(Map.of(
                    "success", true,
                    "studentModalityId", studentModalityId,
                    "documents", documentList,
                    "statistics", Map.of(
                            "totalDocuments", documentList.size(),
                            "uploadedDocuments", 0,
                            "pendingDocuments", documentList.size(),
                            "mandatoryDocuments", documentList.size(),
                            "secondaryDocuments", 0
                    )
            ));
        }



        List<RequiredDocument> allDocuments = requiredDocumentRepository
                .findByModalityIdAndActiveTrueAndDocumentTypeIn(
                        modalityId,
                        List.of(DocumentType.MANDATORY, DocumentType.SECONDARY)
                );


        Map<Long, StudentDocument> uploadedMap = uploadedDocuments.stream()
                .collect(Collectors.toMap(
                        d -> d.getDocumentConfig().getId(),
                        d -> d
                ));


        List<Map<String, Object>> documentList = allDocuments.stream()
                .map(requiredDoc -> {
                    StudentDocument uploaded = uploadedMap.get(requiredDoc.getId());

                    Map<String, Object> docInfo = new HashMap<>();
                    docInfo.put("requiredDocumentId", requiredDoc.getId());
                    docInfo.put("documentName", requiredDoc.getDocumentName());
                    docInfo.put("description", requiredDoc.getDescription());
                    docInfo.put("documentType", requiredDoc.getDocumentType());
                    docInfo.put("allowedFormat", requiredDoc.getAllowedFormat());
                    docInfo.put("maxFileSizeMB", requiredDoc.getMaxFileSizeMB());
                    docInfo.put("uploaded", uploaded != null);

                    if (uploaded != null) {
                        docInfo.put("studentDocumentId", uploaded.getId());
                        docInfo.put("fileName", uploaded.getFileName());
                        docInfo.put("status", uploaded.getStatus());
                        docInfo.put("notes", uploaded.getNotes());
                        docInfo.put("uploadDate", uploaded.getUploadDate());
                    }

                    return docInfo;
                })
                .toList();

        long totalDocuments = documentList.size();
        long uploadedCount = documentList.stream()
                .filter(doc -> (Boolean) doc.get("uploaded"))
                .count();
        long mandatoryCount = documentList.stream()
                .filter(doc -> doc.get("documentType") == DocumentType.MANDATORY)
                .count();
        long secondaryCount = documentList.stream()
                .filter(doc -> doc.get("documentType") == DocumentType.SECONDARY)
                .count();

        return ResponseEntity.ok(Map.of(
                "success", true,
                "studentModalityId", studentModalityId,
                "documents", documentList,
                "statistics", Map.of(
                        "totalDocuments", totalDocuments,
                        "uploadedDocuments", uploadedCount,
                        "pendingDocuments", totalDocuments - uploadedCount,
                        "mandatoryDocuments", mandatoryCount,
                        "secondaryDocuments", secondaryCount
                )
        ));
    }

    public ResponseEntity<?> getStudentDocuments(Long studentModalityId) {

        StudentModality studentModality = studentModalityRepository
                .findById(studentModalityId)
                .orElseThrow(() ->
                        new RuntimeException("Modalidad del estudiante no encontrada")
                );

        List<StudentDocument> documents =
                studentDocumentRepository.findByStudentModalityId(studentModalityId);

        List<Map<String, Object>> response = documents.stream()
                .map(doc -> {
                    Map<String, Object> map = new HashMap<>();
                    map.put("studentDocumentId", doc.getId());
                    map.put("documentName", doc.getDocumentConfig().getDocumentName());
                    map.put("documentType", doc.getDocumentConfig().getDocumentType());
                    map.put("status", doc.getStatus());
                    map.put("notes", doc.getNotes());
                    map.put("uploadedAt", doc.getUploadDate());
                    map.put("filePath", doc.getFilePath());
                    return map;
                })
                .toList();

        return ResponseEntity.ok(response);
    }
    public ResponseEntity<?> viewStudentDocument(Long studentDocumentId) throws MalformedURLException {

        StudentDocument doc = studentDocumentRepository.findById(studentDocumentId)
                .orElseThrow(() -> new RuntimeException("Document not found"));

        Path path = Paths.get(doc.getFilePath());
        if (!Files.exists(path)) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("File not found on server");
        }

        UrlResource resource = new UrlResource(path.toUri());

        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_PDF)
                .header(HttpHeaders.CONTENT_DISPOSITION,
                        "inline; filename=\"" + doc.getFileName() + "\"")
                .body(resource);

    }
    public ResponseEntity<?> reviewStudentDocument(Long studentDocumentId, DocumentReviewDTO request) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User programHead = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentDocument document = studentDocumentRepository.findById(studentDocumentId)
                .orElseThrow(() -> new RuntimeException("Documento no encontrado"));

        AcademicProgram documentProgram = document.getStudentModality().getAcademicProgram();


        boolean authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(programHead.getId(), documentProgram.getId(), ProgramRole.PROGRAM_HEAD);

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tienes permisos para revisar documentos de este programa académico");
        }



        if ((request.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                request.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD)
                && (request.getNotes() == null || request.getNotes().isBlank())) {

            return ResponseEntity.badRequest().body("Debe proporcionar notas al rechazar o solicitar correcciones");
        }

        document.setStatus(request.getStatus());
        document.setNotes(request.getNotes());
        document.setUploadDate(LocalDateTime.now());

        studentDocumentRepository.save(document);


        if (request.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD) {
            StudentModality studentModality = document.getStudentModality();
            LocalDateTime now = LocalDateTime.now();
            studentModality.setCorrectionRequestDate(now);
            studentModality.setCorrectionDeadline(now.plusDays(30));
            studentModality.setCorrectionReminderSent(false);
            studentModality.setUpdatedAt(now);
            studentModalityRepository.save(studentModality);
        }

        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(request.getStatus())
                        .changeDate(LocalDateTime.now())
                        .responsible(programHead)
                        .observations(request.getNotes())
                        .build()
        );

        return ResponseEntity.ok(
                Map.of(
                        "message", "Documento revisado correctamente",
                        "documentId", document.getId(),
                        "newStatus", document.getStatus()
                )
        );
    }

    @Transactional
    public ResponseEntity<?> approveModalityByProgramHead(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User programHead = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modality not found"));


        Long academicProgramId = studentModality.getAcademicProgram().getId();

        boolean isAuthorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                                programHead.getId(),
                                academicProgramId,
                                ProgramRole.PROGRAM_HEAD
                        );

        if (!isAuthorized) {
            return ResponseEntity.status(403).body(
                    Map.of(
                            "approved", false,
                            "message", "No tienes permisos para aprobar modalidades de este programa académico"
                    )
            );
        }


        if (!(studentModality.getStatus() == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD ||
                studentModality.getStatus() == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD)) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "approved", false,
                            "message", "La modalidad no está en un estado válido para ser aprobada por la jefatura de programa",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }

        Long modalityId =
                studentModality
                        .getProgramDegreeModality()
                        .getDegreeModality()
                        .getId();


        List<RequiredDocument> mandatoryDocuments =
                requiredDocumentRepository.findByModalityIdAndActiveTrueAndDocumentType(modalityId, DocumentType.MANDATORY);

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository.findByStudentModalityId(studentModalityId);

        Map<Long, StudentDocument> uploadedMap =
                uploadedDocuments.stream()
                        .collect(Collectors.toMap(
                                doc -> doc.getDocumentConfig().getId(),
                                doc -> doc
                        ));

        List<Map<String, Object>> invalidDocuments = new ArrayList<>();

        for (RequiredDocument required : mandatoryDocuments) {

            StudentDocument uploaded = uploadedMap.get(required.getId());

            if (uploaded == null) {
                invalidDocuments.add(
                        Map.of(
                                "documentName", required.getDocumentName(),
                                "status", "NOT_UPLOADED"
                        )
                );
                continue;
            }

            if (uploaded.getStatus() != DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW) {
                invalidDocuments.add(
                        Map.of(
                                "documentName", required.getDocumentName(),
                                "status", uploaded.getStatus()
                        )
                );
            }
        }

        if (!invalidDocuments.isEmpty()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "approved", false,
                            "message", "Para poder aprobar la modalidad, todos los documentos obligatorios deben estar aceptados",
                            "documents", invalidDocuments
                    )
            );
        }


        studentModality.setStatus(ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE)
                        .changeDate(LocalDateTime.now())
                        .responsible(programHead)
                        .observations("Modalidad aprobada por jefatura de programa")
                        .build()
        );

        notificationEventPublisher.publish(
                new ModalityApprovedByProgramHead(
                        studentModality.getId(),
                        programHead.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "approved", true,
                        "newStatus", ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE,
                        "message", "Modalidad aprobada correctamente y enviada al comité de currículo de programa"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> approveModalityByCommittee(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modality not found"));


        Long academicProgramId = studentModality.getAcademicProgram().getId();

        boolean isAuthorized =
                programAuthorityRepository
                        .existsByUser_IdAndAcademicProgram_IdAndRole(
                                committeeMember.getId(),
                                academicProgramId,
                                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                        );

        if (!isAuthorized) {
            return ResponseEntity.status(403).body(
                    Map.of(
                            "approved", false,
                            "message", "No tienes permisos para aprobar modalidades de este programa académico"
                    )
            );
        }


        if (!(studentModality.getStatus() == ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE ||
                studentModality.getStatus() == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_CURRICULUM_COMMITTEE)) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "approved", false,
                            "message", "La modalidad no está en estado válido para aprobación por el comité de currículo de programa",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        studentModality.setStatus(ModalityProcessStatus.PROPOSAL_APPROVED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.PROPOSAL_APPROVED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations("Modalidad aprobada por el Comité de currículo de programa")
                        .build()
        );

        notificationEventPublisher.publish(
                new ModalityApprovedByCommitteeEvent(
                        studentModality.getId(),
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "approved", true,
                        "newStatus", ModalityProcessStatus.PROPOSAL_APPROVED,
                        "message", "Modalidad aprobada definitivamente por el comité de currículo de programa"
                )
        );
    }

    public ResponseEntity<?> reviewStudentDocumentByCommittee(Long studentDocumentId, DocumentReviewDTO request) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentDocument document = studentDocumentRepository.findById(studentDocumentId)
                .orElseThrow(() -> new RuntimeException("Document not found"));


        StudentModality studentModality = document.getStudentModality();
        Long academicProgramId = studentModality.getAcademicProgram().getId();

        boolean isAuthorized =
                programAuthorityRepository
                        .existsByUser_IdAndAcademicProgram_IdAndRole(
                                committeeMember.getId(),
                                academicProgramId,
                                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                        );

        if (!isAuthorized) {
            return ResponseEntity.status(403).body(
                    Map.of(
                            "success", false,
                            "message", "No tienes permisos para revisar documentos de este programa académico"
                    )
            );
        }


        if ((request.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW ||
                request.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_CURRICULUM_COMMITTEE)
                && (request.getNotes() == null || request.getNotes().isBlank())) {

            return ResponseEntity.badRequest().body(
                    "Debe proporcionar notas al rechazar o solicitar correcciones"
            );
        }


        document.setStatus(request.getStatus());
        document.setNotes(request.getNotes());
        document.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(document);


        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(request.getStatus())
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(request.getNotes())
                        .build()
        );


        if (request.getStatus() ==
                DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_CURRICULUM_COMMITTEE) {


            LocalDateTime now = LocalDateTime.now();
            studentModality.setCorrectionRequestDate(now);
            studentModality.setCorrectionDeadline(now.plusDays(30));
            studentModality.setCorrectionReminderSent(false);
            studentModality.setUpdatedAt(now);
            studentModalityRepository.save(studentModality);


            List<StudentModalityMember> activeMembers = studentModalityMemberRepository
                    .findByStudentModalityIdAndStatus(studentModality.getId(), MemberStatus.ACTIVE);


            for (StudentModalityMember member : activeMembers) {
                notificationEventPublisher.publish(
                        new DocumentCorrectionsRequestedEvent(
                                document.getId(),
                                member.getStudent().getId(),
                                request.getNotes(),
                                NotificationRecipientType.PROGRAM_CURRICULUM_COMMITTEE,
                                committeeMember.getId()
                        )
                );
            }
        }

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "documentId", document.getId(),
                        "documentName", document.getDocumentConfig().getDocumentName(),
                        "newStatus", document.getStatus(),
                        "message", "Documento revisado correctamente por el comité de currículo de programa"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> reviewStudentDocumentByExaminer(Long studentDocumentId, DocumentReviewDTO request) {


        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User examiner = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        boolean hasExaminerRole = examiner.getRoles().stream()
                .anyMatch(role -> role.getName().equals("EXAMINER"));

        if (!hasExaminerRole) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                    Map.of(
                            "success", false,
                            "message", "El usuario no tiene rol de EXAMINER"
                    )
            );
        }


        StudentDocument document = studentDocumentRepository.findById(studentDocumentId)
                .orElseThrow(() -> new RuntimeException("Documento no encontrado"));

        StudentModality studentModality = document.getStudentModality();


        boolean isAssignedToModality = defenseExaminerRepository
                .findByStudentModalityIdAndExaminerId(studentModality.getId(), examiner.getId())
                .isPresent();

        if (!isAssignedToModality) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                    Map.of(
                            "success", false,
                            "message", "No estás asignado como juez de esta modalidad"
                    )
            );
        }


        if ((request.getStatus() == DocumentStatus.REJECTED_FOR_EXAMINER_REVIEW ||
                request.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_EXAMINER)
                && (request.getNotes() == null || request.getNotes().isBlank())) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe proporcionar notas al rechazar o solicitar correcciones"
                    )
            );
        }


        if (request.getStatus() != DocumentStatus.ACCEPTED_FOR_EXAMINER_REVIEW &&
                request.getStatus() != DocumentStatus.REJECTED_FOR_EXAMINER_REVIEW &&
                request.getStatus() != DocumentStatus.CORRECTIONS_REQUESTED_BY_EXAMINER) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Estado de documento inválido para revisión por juez"
                    )
            );
        }


        document.setStatus(request.getStatus());
        document.setNotes(request.getNotes());
        document.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(document);


        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(request.getStatus())
                        .changeDate(LocalDateTime.now())
                        .responsible(examiner)
                        .observations(request.getNotes())
                        .build()
        );


        if (request.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_EXAMINER) {


            studentModality.setStatus(ModalityProcessStatus.CORRECTIONS_REQUESTED_EXAMINERS);

            LocalDateTime now = LocalDateTime.now();
            studentModality.setCorrectionRequestDate(now);
            studentModality.setCorrectionDeadline(now.plusDays(30));
            studentModality.setCorrectionReminderSent(false);
            studentModality.setUpdatedAt(now);
            studentModalityRepository.save(studentModality);


            historyRepository.save(
                    ModalityProcessStatusHistory.builder()
                            .studentModality(studentModality)
                            .status(ModalityProcessStatus.CORRECTIONS_REQUESTED_EXAMINERS)
                            .changeDate(now)
                            .responsible(examiner)
                            .observations("Juez " + examiner.getName() + " " + examiner.getLastName() +
                                    " solicitó correcciones: " + request.getNotes())
                            .build()
            );


            List<StudentModalityMember> activeMembers = studentModalityMemberRepository
                    .findByStudentModalityIdAndStatus(studentModality.getId(), MemberStatus.ACTIVE);


            for (StudentModalityMember member : activeMembers) {
                notificationEventPublisher.publish(
                        new DocumentCorrectionsRequestedEvent(
                                document.getId(),
                                member.getStudent().getId(),
                                request.getNotes(),
                                NotificationRecipientType.PROGRAM_CURRICULUM_COMMITTEE,
                                examiner.getId()
                        )
                );
            }
        }
        else if (request.getStatus() == DocumentStatus.ACCEPTED_FOR_EXAMINER_REVIEW) {


            boolean allDocumentsAcceptedByAllExaminers = checkIfAllDocumentsAcceptedByAllExaminers(studentModality.getId());

            if (allDocumentsAcceptedByAllExaminers) {

                studentModality.setStatus(ModalityProcessStatus.READY_FOR_DEFENSE);
                studentModality.setUpdatedAt(LocalDateTime.now());
                studentModalityRepository.save(studentModality);


                historyRepository.save(
                        ModalityProcessStatusHistory.builder()
                                .studentModality(studentModality)
                                .status(ModalityProcessStatus.READY_FOR_DEFENSE)
                                .changeDate(LocalDateTime.now())
                                .responsible(examiner)
                                .observations("Todos los documentos han sido aprobados por todos los jueces. " +
                                        "La modalidad está lista para la sustentación.")
                                .build()
                );
            }
        }


        String message = switch (request.getStatus()) {
            case ACCEPTED_FOR_EXAMINER_REVIEW -> "Documento aceptado correctamente por el juez";
            case REJECTED_FOR_EXAMINER_REVIEW -> "Documento rechazado por el juez";
            case CORRECTIONS_REQUESTED_BY_EXAMINER -> "Correcciones solicitadas al estudiante. Cuando resuba el documento, volverá directamente a revisión del juez";
            default -> "Documento revisado correctamente";
        };

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "documentId", document.getId(),
                        "documentName", document.getDocumentConfig().getDocumentName(),
                        "newStatus", document.getStatus(),
                        "examinerName", examiner.getName() + " " + examiner.getLastName(),
                        "message", message
                )
        );
    }


    private boolean checkIfAllDocumentsAcceptedByAllExaminers(Long studentModalityId) {


        List<StudentDocument> documents = studentDocumentRepository.findByStudentModalityId(studentModalityId);

        if (documents.isEmpty()) {
            return false;
        }


        List<DefenseExaminer> assignedExaminers = defenseExaminerRepository
                .findByStudentModalityId(studentModalityId);

        if (assignedExaminers.isEmpty()) {
            return false;
        }


        for (StudentDocument document : documents) {


            List<StudentDocumentStatusHistory> documentHistory = documentHistoryRepository
                    .findByStudentDocumentIdOrderByChangeDateDesc(document.getId());


            Set<Long> examinersWhoAccepted = new HashSet<>();

            for (StudentDocumentStatusHistory history : documentHistory) {
                if (history.getStatus() == DocumentStatus.ACCEPTED_FOR_EXAMINER_REVIEW &&
                    history.getResponsible() != null) {
                    examinersWhoAccepted.add(history.getResponsible().getId());
                }
            }


            for (DefenseExaminer examiner : assignedExaminers) {
                if (!examinersWhoAccepted.contains(examiner.getExaminer().getId())) {

                    return false;
                }
            }
        }


        return true;
    }

    private String describeModalityStatus(ModalityProcessStatus status) {

        return switch (status) {

            case MODALITY_SELECTED ->
                    "Haz seleccionado una modalidad de grado. Debes cargar los documentos requeridos para esta modalidad.";

            case UNDER_REVIEW_PROGRAM_HEAD ->
                    "La jefatura del programa está revisando tu modalidad de grado. Asegúrate de que todos los documentos obligatorios estén cargados.";

            case CORRECTIONS_REQUESTED_PROGRAM_HEAD ->
                    "La jefatura del programa solicitó correcciones. Debes ajustar la información requerida.";

            case READY_FOR_PROGRAM_CURRICULUM_COMMITTEE ->
                    "La jefatura de programa aprobó tu modalidad de grado. Está pendiente de revisión por el comité de currículo de programa.";

            case UNDER_REVIEW_PROGRAM_CURRICULUM_COMMITTEE ->
                    "El comité de currículo de programa está revisando tu modalidad de grado.";

            case CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE ->
                    "El comité de currículo de programa solicitó correcciones. Debes ajustar la información requerida.";

            case PROPOSAL_APPROVED ->
                    "Tu modalidad fue aprobada por el comité de currículo de programa.";

            case DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR ->
                    "El director de proyecto ha propuesto fecha y lugar de sustentación. Pendiente de aprobación por el comité de currículo de programa.";

            case DEFENSE_SCHEDULED ->
                    "La sustentación ha sido programada por el comité de currículo de programa.";

            case EXAMINERS_ASSIGNED ->
                    "Los jueces han sido asignados a tu sustentación. Están revisando tu documentación.";

            case CORRECTIONS_REQUESTED_EXAMINERS ->
                    "Uno o más jueces solicitaron correcciones en la documentación. Por favor, ajusta los documentos según las observaciones recibidas.";

            case READY_FOR_DEFENSE ->
                    "Todos los documentos han sido aprobados por los jueces. Tu modalidad está lista para la sustentación.";

            case DEFENSE_COMPLETED ->
                    "La sustentación se ha completado. Pendiente de calificación final.";

            case GRADED_APPROVED ->
                    "¡Felicitaciones! Tu modalidad de grado ha sido aprobada.";

            case GRADED_FAILED ->
                    "La modalidad de grado no fue aprobada.";

            case MODALITY_CANCELLED ->
                    "La modalidad fue cancelada.";

            case CANCELLATION_REQUESTED ->
                    "Solicitud de cancelación enviada. Pendiente de revisión.";

            case CANCELLATION_REJECTED ->
                    "La solicitud de cancelación fue rechazada.";

            case CANCELLED_WITHOUT_REPROVAL ->
                    "La modalidad fue cancelada sin reprobación.";

            case MODALITY_CLOSED ->
                    "La modalidad fue cerrada.";

            default ->
                    "Estado del proceso no definido.";
        };
    }

    private String describeDocumentStatus(DocumentStatus status) {
        return switch (status) {
            case PENDING ->
                    "El documento ha sido cargado y está pendiente de revisión.";
            case ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ->
                    "El documento fue aceptado para revisión por la jefatura del programa.";
            case REJECTED_FOR_PROGRAM_HEAD_REVIEW ->
                    "El documento fue rechazado por la jefatura del programa. Revisa las observaciones.";
            case CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD ->
                    "La jefatura del programa solicitó correcciones. Revisa las observaciones y carga una nueva versión.";
            case CORRECTION_RESUBMITTED ->
                    "La corrección ha sido reenviada y está pendiente de revisión.";
            case ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW ->
                    "El documento fue aceptado para revisión por el comité de currículo del programa.";
            case REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW ->
                    "El documento fue rechazado por el comité de currículo del programa. Revisa las observaciones.";
            case CORRECTIONS_REQUESTED_BY_PROGRAM_CURRICULUM_COMMITTEE ->
                    "El comité de currículo del programa solicitó correcciones. Revisa las observaciones y carga una nueva versión.";
            default ->
                    "Estado del documento no definido.";
        };
    }

    public ResponseEntity<?> getCurrentStudentModality() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentModality studentModality = studentModalityRepository
                .findTopByStudentIdOrderByUpdatedAtDesc(student.getId())
                .orElseThrow(() ->
                        new RuntimeException("Not current modality found for the student")
                );


        DegreeModality modality = studentModality.getProgramDegreeModality().getDegreeModality();


        StudentProfile studentProfile = studentProfileRepository.findByUserId(student.getId())
                .orElse(null);


        List<ModalityProcessStatusHistory> historyEntities =
                historyRepository.findByStudentModalityIdOrderByChangeDateAsc(
                        studentModality.getId()
                );

        List<ModalityStatusHistoryDTO> history = historyEntities.stream()
                .map(h -> ModalityStatusHistoryDTO.builder()
                        .status(h.getStatus().name())
                        .description(describeModalityStatus(h.getStatus()))
                        .changeDate(h.getChangeDate())
                        .responsible(
                                h.getResponsible() != null
                                        ? h.getResponsible().getEmail()
                                        : "Sistema"
                        )
                        .observations(h.getObservations())
                        .build()
                )
                .toList();


        List<StudentDocument> documents = studentDocumentRepository
                .findByStudentModalityId(studentModality.getId());

        List<DetailDocumentDTO> documentDTOs = documents.stream()
                .map(doc -> DetailDocumentDTO.builder()
                        .studentDocumentId(doc.getId())
                        .documentName(doc.getDocumentConfig().getDocumentName())
                        .documentType(doc.getDocumentConfig().getDocumentType())
                        .status(doc.getStatus().name())
                        .statusDescription(describeDocumentStatus(doc.getStatus()))
                        .notes(doc.getNotes())
                        .lastUpdate(doc.getUploadDate())
                        .uploaded(true)
                        .build()
                )
                .toList();


        long approvedDocs = documents.stream()
                .filter(d -> d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();
        long pendingDocs = documents.stream()
                .filter(d -> d.getStatus() == DocumentStatus.PENDING ||
                        d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ||
                        d.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED)
                .count();
        long rejectedDocs = documents.stream()
                .filter(d -> d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                        d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();


        Long daysRemaining = null;
        if (studentModality.getCorrectionDeadline() != null) {
            daysRemaining = ChronoUnit.DAYS.between(
                    LocalDateTime.now(),
                    studentModality.getCorrectionDeadline()
            );
        }


        ModalityProcessStatus status = studentModality.getStatus();
        boolean canUploadDocuments = status == ModalityProcessStatus.MODALITY_SELECTED ||
                status == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD ||
                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;

        boolean canRequestCancellation = status != ModalityProcessStatus.MODALITY_CLOSED &&
                status != ModalityProcessStatus.GRADED_APPROVED &&
                status != ModalityProcessStatus.GRADED_FAILED &&
                !status.name().startsWith("CANCELLED");

        boolean canSubmitCorrections = (status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) &&
                studentModality.getCorrectionDeadline() != null &&
                LocalDateTime.now().isBefore(studentModality.getCorrectionDeadline());

        boolean hasDefenseScheduled = studentModality.getDefenseDate() != null;

        boolean requiresAction = canUploadDocuments || canSubmitCorrections ||
                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;


        User projectDirector = studentModality.getProjectDirector();
        String defenseProposedBy = null;
        if (status == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR) {
            defenseProposedBy = "El director de proyecto ha propuesto una fecha de sustentación";
        }

        return ResponseEntity.ok(
                StudentModalityDTO.builder()

                        .studentId(student.getId())
                        .studentName(student.getName())
                        .studentLastName(student.getLastName())
                        .studentEmail(student.getEmail())
                        .studentCode(studentProfile != null ? studentProfile.getStudentCode() : null)
                        .approvedCredits(studentProfile != null ? studentProfile.getApprovedCredits() : null)
                        .gpa(studentProfile != null ? studentProfile.getGpa() : null)
                        .semester(studentProfile != null ? studentProfile.getSemester() : null)


                        .facultyName(studentModality.getProgramDegreeModality()
                                .getAcademicProgram().getFaculty().getName())
                        .academicProgramName(studentModality.getProgramDegreeModality()
                                .getAcademicProgram().getName())


                        .studentModalityId(studentModality.getId())
                        .modalityId(modality.getId())
                        .modalityName(modality.getName())
                        .modalityDescription(modality.getDescription())
                        .creditsRequired(studentModality.getProgramDegreeModality()
                                .getCreditsRequired())
                        .modalityType(null)


                        .currentStatus(status.name())
                        .currentStatusDescription(describeModalityStatus(status))
                        .selectionDate(studentModality.getSelectionDate())
                        .lastUpdatedAt(studentModality.getUpdatedAt())


                        .projectDirectorId(projectDirector != null ? projectDirector.getId() : null)
                        .projectDirectorName(projectDirector != null
                                ? projectDirector.getName() + " " + projectDirector.getLastName()
                                : null)
                        .projectDirectorEmail(projectDirector != null ? projectDirector.getEmail() : null)


                        .defenseDate(studentModality.getDefenseDate())
                        .defenseLocation(studentModality.getDefenseLocation())
                        .defenseProposedByProjectDirector(defenseProposedBy)


                        .academicDistinction(studentModality.getAcademicDistinction() != null
                                ? studentModality.getAcademicDistinction().name()
                                : null)


                        .correctionRequestDate(studentModality.getCorrectionRequestDate())
                        .correctionDeadline(studentModality.getCorrectionDeadline())
                        .correctionReminderSent(studentModality.getCorrectionReminderSent())
                        .daysRemainingForCorrection(daysRemaining)


                        .documents(documentDTOs)
                        .totalDocuments(documents.size())
                        .approvedDocuments((int) approvedDocs)
                        .pendingDocuments((int) pendingDocs)
                        .rejectedDocuments((int) rejectedDocs)


                        .history(history)


                        .canUploadDocuments(canUploadDocuments)
                        .canRequestCancellation(canRequestCancellation)
                        .canSubmitCorrections(canSubmitCorrections)
                        .hasDefenseScheduled(hasDefenseScheduled)
                        .requiresAction(requiresAction)

                        .build()
        );
    }

    public ResponseEntity<?> getAllStudentModalitiesForProgramHead(List<ModalityProcessStatus> statuses, String name) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User programHead = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        List<Long> programIds = programAuthorityRepository
                        .findByUser_Id(programHead.getId())
                        .stream()
                        .filter(pa -> pa.getRole() == ProgramRole.PROGRAM_HEAD)
                        .map(pa -> pa.getAcademicProgram().getId())
                        .toList();

        if (programIds.isEmpty()) {
            return ResponseEntity.ok(List.of());
        }

        boolean hasStatusFilter = statuses != null && !statuses.isEmpty();
        boolean hasNameFilter = name != null && !name.isBlank();

        List<StudentModality> modalities;

        if (hasStatusFilter && hasNameFilter) {

            modalities =
                    studentModalityRepository.findForProgramHeadWithStatusAndName(programIds, statuses, name);

        } else if (hasStatusFilter) {

            modalities =
                    studentModalityRepository
                            .findForProgramHeadWithStatus(programIds, statuses);

        } else if (hasNameFilter) {

            modalities =
                    studentModalityRepository
                            .findForProgramHeadWithName(programIds, name);

        } else {

            modalities =
                    studentModalityRepository
                            .findForProgramHead(programIds);
        }

        List<ModalityListDTO> response =
                modalities.stream()
                        .map(sm -> {

                            ModalityProcessStatus status = sm.getStatus();

                            boolean pending =
                                    status == ModalityProcessStatus.MODALITY_SELECTED ||
                                            status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD;

                            // Obtener todos los miembros activos de la modalidad
                            List<StudentModalityMember> activeMembers =
                                studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                                    sm.getId(),
                                    MemberStatus.ACTIVE
                                );

                            // Concatenar nombres de los miembros (solo nombres, no apellidos)
                            String studentNames = activeMembers.stream()
                                    .map(member -> member.getStudent().getName() + " " + member.getStudent().getLastName())
                                    .collect(Collectors.joining(", "));

                            // Concatenar emails de los miembros
                            String studentEmails = activeMembers.stream()
                                    .map(member -> member.getStudent().getEmail())
                                    .collect(Collectors.joining(", "));

                            return ModalityListDTO.builder()
                                    .studentModalityId(sm.getId())
                                    .studentName(studentNames)
                                    .studentEmail(studentEmails)
                                    .modalityName(
                                            sm.getProgramDegreeModality()
                                                    .getDegreeModality()
                                                    .getName()
                                    )
                                    .currentStatus(status.name())
                                    .currentStatusDescription(describeModalityStatus(status))
                                    .lastUpdatedAt(sm.getUpdatedAt())
                                    .hasPendingActions(pending)
                                    .build();
                        })
                        .toList();

        return ResponseEntity.ok(response);
    }

    public ResponseEntity<?> getAllStudentModalitiesForProgramCurriculumCommittee(List<ModalityProcessStatus> statuses, String name) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        List<Long> programIds = programAuthorityRepository
                .findByUser_Id(committeeMember.getId())
                .stream()
                .filter(pa -> pa.getRole() == ProgramRole.PROGRAM_CURRICULUM_COMMITTEE)
                .map(pa -> pa.getAcademicProgram().getId())
                .toList();

        if (programIds.isEmpty()) {
            return ResponseEntity.ok(List.of());
        }


        List<ModalityProcessStatus> committeeRelevantStatuses = List.of(
                ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE,
                ModalityProcessStatus.UNDER_REVIEW_PROGRAM_CURRICULUM_COMMITTEE,
                ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE,
                ModalityProcessStatus.PROPOSAL_APPROVED,
                ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR,
                ModalityProcessStatus.DEFENSE_SCHEDULED
        );


        List<ModalityProcessStatus> finalStatuses;
        if (statuses != null && !statuses.isEmpty()) {

            finalStatuses = statuses.stream()
                    .filter(committeeRelevantStatuses::contains)
                    .toList();


            if (finalStatuses.isEmpty()) {
                return ResponseEntity.ok(List.of());
            }
        } else {

            finalStatuses = committeeRelevantStatuses;
        }

        boolean hasNameFilter = name != null && !name.isBlank();

        List<StudentModality> modalities;

        if (hasNameFilter) {
            modalities = studentModalityRepository
                    .findForProgramHeadWithStatusAndName(programIds, finalStatuses, name);
        } else {
            modalities = studentModalityRepository
                    .findForProgramHeadWithStatus(programIds, finalStatuses);
        }

        List<ModalityListDTO> response =
                modalities.stream()
                        .map(sm -> {

                            ModalityProcessStatus status = sm.getStatus();

                            boolean pending =
                                    status == ModalityProcessStatus.READY_FOR_PROGRAM_CURRICULUM_COMMITTEE ||
                                            status == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_CURRICULUM_COMMITTEE ||
                                            status == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR;

                            // Obtener todos los miembros activos de la modalidad
                            List<StudentModalityMember> activeMembers =
                                    studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                                            sm.getId(),
                                            MemberStatus.ACTIVE
                                    );

                            // Concatenar nombres de los miembros (solo nombres, no apellidos)
                            String studentNames = activeMembers.stream()
                                    .map(member -> member.getStudent().getName() + " " + member.getStudent().getLastName())
                                    .collect(Collectors.joining(", "));

                            // Concatenar emails de los miembros
                            String studentEmails = activeMembers.stream()
                                    .map(member -> member.getStudent().getEmail())
                                    .collect(Collectors.joining(", "));

                            return ModalityListDTO.builder()
                                    .studentModalityId(sm.getId())
                                    .studentName(studentNames)
                                    .studentEmail(studentEmails)
                                    .modalityName(
                                            sm.getProgramDegreeModality()
                                                    .getDegreeModality()
                                                    .getName()
                                    )
                                    .currentStatus(status.name())
                                    .currentStatusDescription(describeModalityStatus(status))
                                    .lastUpdatedAt(sm.getUpdatedAt())
                                    .hasPendingActions(pending)
                                    .build();
                        })
                        .toList();



        return ResponseEntity.ok(response);
    }

    public ResponseEntity<?> getAllStudentModalitiesForProjectDirector(List<ModalityProcessStatus> statuses, String name) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User projectDirector = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<ProgramAuthority> directorAuthorities = programAuthorityRepository
                .findByUser_Id(projectDirector.getId())
                .stream()
                .filter(pa -> pa.getRole() == ProgramRole.PROJECT_DIRECTOR)
                .toList();

        if (directorAuthorities.isEmpty()) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("El usuario no tiene el rol de PROJECT_DIRECTOR");
        }

        boolean hasStatusFilter = statuses != null && !statuses.isEmpty();
        boolean hasNameFilter = name != null && !name.isBlank();

        List<StudentModality> modalities;

        if (hasStatusFilter && hasNameFilter) {
            modalities = studentModalityRepository
                    .findForProjectDirectorWithStatusAndName(projectDirector.getId(), statuses, name);
        } else if (hasStatusFilter) {
            modalities = studentModalityRepository
                    .findForProjectDirectorWithStatus(projectDirector.getId(), statuses);
        } else if (hasNameFilter) {
            modalities = studentModalityRepository
                    .findForProjectDirectorWithName(projectDirector.getId(), name);
        } else {
            modalities = studentModalityRepository
                    .findForProjectDirector(projectDirector.getId());
        }

        List<ModalityListDTO> response = modalities.stream()
                .map(sm -> {
                    ModalityProcessStatus status = sm.getStatus();


                    boolean pending =
                            status == ModalityProcessStatus.PROPOSAL_APPROVED ||
                            status == ModalityProcessStatus.CANCELLATION_REQUESTED;


                    // Obtener todos los miembros activos de la modalidad
                    List<StudentModalityMember> activeMembers =
                            studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                                    sm.getId(),
                                    MemberStatus.ACTIVE
                            );

                    // Concatenar nombres de los miembros (solo nombres, no apellidos)
                    String studentNames = activeMembers.stream()
                            .map(member -> member.getStudent().getName() + " " + member.getStudent().getLastName())
                            .collect(Collectors.joining(", "));

                    // Concatenar emails de los miembros
                    String studentEmails = activeMembers.stream()
                            .map(member -> member.getStudent().getEmail())
                            .collect(Collectors.joining(", "));


                    return ModalityListDTO.builder()
                            .studentModalityId(sm.getId())
                            .studentName(studentNames)
                            .studentEmail(studentEmails)
                            .modalityName(sm.getProgramDegreeModality().getDegreeModality().getName())
                            .currentStatus(status.name())
                            .currentStatusDescription(describeModalityStatus(status))
                            .lastUpdatedAt(sm.getUpdatedAt())
                            .hasPendingActions(pending)
                            .build();
                })
                .toList();

        return ResponseEntity.ok(response);
    }

    public ResponseEntity<?> getAllStudentModalitiesForExaminer(List<ModalityProcessStatus> statuses, String name) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User examiner = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<DefenseExaminer> examinerAssignments = defenseExaminerRepository
                .findByExaminerId(examiner.getId());

        if (examinerAssignments.isEmpty()) {
            return ResponseEntity.ok(List.of());
        }

        boolean hasStatusFilter = statuses != null && !statuses.isEmpty();
        boolean hasNameFilter = name != null && !name.isBlank();

        List<StudentModality> modalities;

        if (hasStatusFilter && hasNameFilter) {
            modalities = studentModalityRepository
                    .findForExaminerWithStatusAndName(examiner.getId(), statuses, name);
        } else if (hasStatusFilter) {
            modalities = studentModalityRepository
                    .findForExaminerWithStatus(examiner.getId(), statuses);
        } else if (hasNameFilter) {
            modalities = studentModalityRepository
                    .findForExaminerWithName(examiner.getId(), name);
        } else {
            modalities = studentModalityRepository
                    .findForExaminer(examiner.getId());
        }

        List<ModalityListDTO> response = modalities.stream()
                .map(sm -> {
                    ModalityProcessStatus status = sm.getStatus();


                    boolean pending =
                            status == ModalityProcessStatus.DEFENSE_SCHEDULED;

                    // Obtener todos los miembros activos de la modalidad
                    List<StudentModalityMember> activeMembers =
                            studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                                    sm.getId(),
                                    MemberStatus.ACTIVE
                            );

                    // Concatenar nombres de los miembros (solo nombres, no apellidos)
                    String studentNames = activeMembers.stream()
                            .map(member -> member.getStudent().getName() + " " + member.getStudent().getLastName())
                            .collect(Collectors.joining(", "));

                    // Concatenar emails de los miembros
                    String studentEmails = activeMembers.stream()
                            .map(member -> member.getStudent().getEmail())
                            .collect(Collectors.joining(", "));



                    return ModalityListDTO.builder()
                            .studentModalityId(sm.getId())
                            .studentName(studentNames)
                            .studentEmail(studentEmails)
                            .modalityName(sm.getProgramDegreeModality().getDegreeModality().getName())
                            .currentStatus(status.name())
                            .currentStatusDescription(describeModalityStatus(status))
                            .lastUpdatedAt(sm.getUpdatedAt())
                            .hasPendingActions(pending)
                            .build();
                })
                .toList();

        return ResponseEntity.ok(response);
    }

    public ResponseEntity<?> getStudentModalityDetailForProgramHead(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User programHead = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modality not found"));

        AcademicProgram academicProgram = studentModality.getProgramDegreeModality().getAcademicProgram();

        boolean authorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        programHead.getId(),
                        academicProgram.getId(),
                        ProgramRole.PROGRAM_HEAD
                );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para ver esta modalidad");
        }

        // Obtener todos los miembros activos de la modalidad
        List<StudentModalityMember> activeMembers =
            studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                studentModalityId,
                MemberStatus.ACTIVE
            );

        // Para compatibilidad, usar el líder como estudiante principal
        User student = studentModality.getLeader();
        DegreeModality modality =
                studentModality.getProgramDegreeModality().getDegreeModality();


        StudentProfile studentProfile = studentProfileRepository.findByUserId(student.getId())
                .orElse(null);


        List<ModalityStatusHistoryDTO> history =
                historyRepository
                        .findByStudentModalityIdOrderByChangeDateAsc(studentModalityId)
                        .stream()
                        .map(h -> ModalityStatusHistoryDTO.builder()
                                .status(h.getStatus().name())
                                .description(describeModalityStatus(h.getStatus()))
                                .changeDate(h.getChangeDate())
                                .responsible(
                                        h.getResponsible() != null
                                                ? h.getResponsible().getEmail()
                                                : "Sistema"
                                )
                                .observations(h.getObservations())
                                .build()
                        )
                        .toList();


        List<RequiredDocument> requiredDocuments =
                requiredDocumentRepository
                        .findByModalityIdAndActiveTrue(modality.getId());

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository
                        .findByStudentModalityId(studentModalityId);

        Map<Long, StudentDocument> uploadedMap =
                uploadedDocuments.stream()
                        .collect(Collectors.toMap(
                                d -> d.getDocumentConfig().getId(),
                                d -> d
                        ));

        List<DetailDocumentDTO> documents =
                requiredDocuments.stream()
                        .map(req -> {
                            StudentDocument uploaded = uploadedMap.get(req.getId());

                            return DetailDocumentDTO.builder()
                                    .studentDocumentId(
                                            uploaded != null ? uploaded.getId() : null
                                    )
                                    .documentName(req.getDocumentName())
                                    .documentType(req.getDocumentType())
                                    .uploaded(uploaded != null)
                                    .status(
                                            uploaded != null
                                                    ? uploaded.getStatus().name()
                                                    : "NOT_UPLOADED"
                                    )
                                    .statusDescription(
                                            uploaded != null
                                                    ? describeDocumentStatus(uploaded.getStatus())
                                                    : "Documento aún no cargado por el estudiante."
                                    )
                                    .notes(
                                            uploaded != null ? uploaded.getNotes() : null
                                    )
                                    .lastUpdate(
                                            uploaded != null ? uploaded.getUploadDate() : null
                                    )
                                    .build();
                        })
                        .toList();


        long approvedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();
        long pendingDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.PENDING ||
                            d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED)
                .count();
        long rejectedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();


        Long daysRemaining = null;
        if (studentModality.getCorrectionDeadline() != null) {
            daysRemaining = ChronoUnit.DAYS.between(
                    LocalDateTime.now(),
                    studentModality.getCorrectionDeadline()
            );
        }


        ModalityProcessStatus status = studentModality.getStatus();
        boolean canUploadDocuments = status == ModalityProcessStatus.MODALITY_SELECTED ||
                                    status == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;

        boolean canRequestCancellation = status != ModalityProcessStatus.MODALITY_CLOSED &&
                                        status != ModalityProcessStatus.GRADED_APPROVED &&
                                        status != ModalityProcessStatus.GRADED_FAILED &&
                                        !status.name().startsWith("CANCELLED");

        boolean canSubmitCorrections = (status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                       status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) &&
                                      studentModality.getCorrectionDeadline() != null &&
                                      LocalDateTime.now().isBefore(studentModality.getCorrectionDeadline());

        boolean hasDefenseScheduled = studentModality.getDefenseDate() != null;

        boolean requiresAction = canUploadDocuments || canSubmitCorrections ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;


        User projectDirector = studentModality.getProjectDirector();
        String defenseProposedBy = null;
        if (status == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR) {
            defenseProposedBy = "El director de proyecto ha propuesto una fecha de sustentación";
        }

        // Convertir miembros activos a DTOs
        List<ModalityMemberDTO> memberDTOs = activeMembers.stream()
                .map(member -> {
                    StudentProfile memberProfile = studentProfileRepository
                            .findByUserId(member.getStudent().getId())
                            .orElse(null);

                    return ModalityMemberDTO.builder()
                            .memberId(member.getId())
                            .studentId(member.getStudent().getId())
                            .studentName(member.getStudent().getName())
                            .studentLastName(member.getStudent().getLastName())
                            .studentEmail(member.getStudent().getEmail())
                            .studentCode(memberProfile != null ? memberProfile.getStudentCode() : null)
                            .isLeader(member.getIsLeader())
                            .status(member.getStatus().name())
                            .joinedAt(member.getJoinedAt())
                            .build();
                })
                .toList();

        return ResponseEntity.ok(
                StudentModalityDTO.builder()
                        .studentId(student.getId())
                        .studentName(student.getName())
                        .studentLastName(student.getLastName())
                        .studentEmail(student.getEmail())
                        .studentCode(studentProfile != null ? studentProfile.getStudentCode() : null)
                        .approvedCredits(studentProfile != null ? studentProfile.getApprovedCredits() : null)
                        .gpa(studentProfile != null ? studentProfile.getGpa() : null)
                        .semester(studentProfile != null ? studentProfile.getSemester() : null)


                        .facultyName(academicProgram.getFaculty().getName())
                        .academicProgramName(academicProgram.getName())


                        .studentModalityId(studentModality.getId())
                        .modalityName(modality.getName())
                        .modalityDescription(modality.getDescription())
                        .creditsRequired(studentModality.getProgramDegreeModality().getCreditsRequired())
                        .modalityType(studentModality.getModalityType() != null
                                ? studentModality.getModalityType().name()
                                : null)
                        .members(memberDTOs)


                        .currentStatus(status.name())
                        .currentStatusDescription(describeModalityStatus(status))
                        .selectionDate(studentModality.getSelectionDate())
                        .lastUpdatedAt(studentModality.getUpdatedAt())


                        .projectDirectorId(projectDirector != null ? projectDirector.getId() : null)
                        .projectDirectorName(projectDirector != null
                                ? projectDirector.getName() + " " + projectDirector.getLastName()
                                : null)
                        .projectDirectorEmail(projectDirector != null ? projectDirector.getEmail() : null)


                        .defenseDate(studentModality.getDefenseDate())
                        .defenseLocation(studentModality.getDefenseLocation())
                        .defenseProposedByProjectDirector(defenseProposedBy)


                        .academicDistinction(studentModality.getAcademicDistinction() != null
                                ? studentModality.getAcademicDistinction().name()
                                : null)


                        .correctionRequestDate(studentModality.getCorrectionRequestDate())
                        .correctionDeadline(studentModality.getCorrectionDeadline())
                        .correctionReminderSent(studentModality.getCorrectionReminderSent())
                        .daysRemainingForCorrection(daysRemaining)


                        .documents(documents)
                        .totalDocuments(uploadedDocuments.size())
                        .approvedDocuments((int) approvedDocs)
                        .pendingDocuments((int) pendingDocs)
                        .rejectedDocuments((int) rejectedDocs)


                        .history(history)


                        .canUploadDocuments(canUploadDocuments)
                        .canRequestCancellation(canRequestCancellation)
                        .canSubmitCorrections(canSubmitCorrections)
                        .hasDefenseScheduled(hasDefenseScheduled)
                        .requiresAction(requiresAction)

                        .build()
        );
    }

    public ResponseEntity<?> getStudentModalityDetailForCommittee(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modality not found"));

        AcademicProgram academicProgram = studentModality.getProgramDegreeModality().getAcademicProgram();

        boolean authorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        committeeMember.getId(),
                        academicProgram.getId(),
                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para ver esta modalidad");
        }



        List<StudentModalityMember> activeMembers =
                studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                        studentModalityId,
                        MemberStatus.ACTIVE
                );


        User student = studentModality.getLeader();
        DegreeModality modality =
                studentModality.getProgramDegreeModality().getDegreeModality();




        StudentProfile studentProfile = studentProfileRepository.findByUserId(student.getId())
                .orElse(null);


        List<ModalityStatusHistoryDTO> history =
                historyRepository
                        .findByStudentModalityIdOrderByChangeDateAsc(studentModalityId)
                        .stream()
                        .map(h -> ModalityStatusHistoryDTO.builder()
                                .status(h.getStatus().name())
                                .description(describeModalityStatus(h.getStatus()))
                                .changeDate(h.getChangeDate())
                                .responsible(
                                        h.getResponsible() != null
                                                ? h.getResponsible().getEmail()
                                                : "Sistema"
                                )
                                .observations(h.getObservations())
                                .build()
                        )
                        .toList();


        List<RequiredDocument> requiredDocuments =
                requiredDocumentRepository
                        .findByModalityIdAndActiveTrue(modality.getId());

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository
                        .findByStudentModalityId(studentModalityId);

        Map<Long, StudentDocument> uploadedMap =
                uploadedDocuments.stream()
                        .collect(Collectors.toMap(
                                d -> d.getDocumentConfig().getId(),
                                d -> d
                        ));

        List<DetailDocumentDTO> documents =
                requiredDocuments.stream()
                        .map(req -> {
                            StudentDocument uploaded = uploadedMap.get(req.getId());

                            return DetailDocumentDTO.builder()
                                    .studentDocumentId(
                                            uploaded != null ? uploaded.getId() : null
                                    )
                                    .documentName(req.getDocumentName())
                                    .documentType(req.getDocumentType())
                                    .uploaded(uploaded != null)
                                    .status(
                                            uploaded != null
                                                    ? uploaded.getStatus().name()
                                                    : "NOT_UPLOADED"
                                    )
                                    .statusDescription(
                                            uploaded != null
                                                    ? describeDocumentStatus(uploaded.getStatus())
                                                    : "Documento aún no cargado por el estudiante."
                                    )
                                    .notes(
                                            uploaded != null ? uploaded.getNotes() : null
                                    )
                                    .lastUpdate(
                                            uploaded != null ? uploaded.getUploadDate() : null
                                    )
                                    .build();
                        })
                        .toList();


        long approvedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();
        long pendingDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.PENDING ||
                            d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED)
                .count();
        long rejectedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();


        Long daysRemaining = null;
        if (studentModality.getCorrectionDeadline() != null) {
            daysRemaining = ChronoUnit.DAYS.between(
                    LocalDateTime.now(),
                    studentModality.getCorrectionDeadline()
            );
        }


        ModalityProcessStatus status = studentModality.getStatus();
        boolean canUploadDocuments = status == ModalityProcessStatus.MODALITY_SELECTED ||
                                    status == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;

        boolean canRequestCancellation = status != ModalityProcessStatus.MODALITY_CLOSED &&
                                        status != ModalityProcessStatus.GRADED_APPROVED &&
                                        status != ModalityProcessStatus.GRADED_FAILED &&
                                        !status.name().startsWith("CANCELLED");

        boolean canSubmitCorrections = (status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                       status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) &&
                                      studentModality.getCorrectionDeadline() != null &&
                                      LocalDateTime.now().isBefore(studentModality.getCorrectionDeadline());

        boolean hasDefenseScheduled = studentModality.getDefenseDate() != null;

        boolean requiresAction = canUploadDocuments || canSubmitCorrections ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;


        User projectDirector = studentModality.getProjectDirector();
        String defenseProposedBy = null;
        if (status == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR) {
            defenseProposedBy = "El director de proyecto ha propuesto una fecha de sustentación";
        }


        List<ModalityMemberDTO> memberDTOs = activeMembers.stream()
                .map(member -> {
                    StudentProfile memberProfile = studentProfileRepository
                            .findByUserId(member.getStudent().getId())
                            .orElse(null);

                    return ModalityMemberDTO.builder()
                            .memberId(member.getId())
                            .studentId(member.getStudent().getId())
                            .studentName(member.getStudent().getName())
                            .studentLastName(member.getStudent().getLastName())
                            .studentEmail(member.getStudent().getEmail())
                            .studentCode(memberProfile != null ? memberProfile.getStudentCode() : null)
                            .isLeader(member.getIsLeader())
                            .status(member.getStatus().name())
                            .joinedAt(member.getJoinedAt())
                            .build();
                })
                .toList();

        return ResponseEntity.ok(
                StudentModalityDTO.builder()

                        .studentId(student.getId())
                        .studentName(student.getName())
                        .studentLastName(student.getLastName())
                        .studentEmail(student.getEmail())
                        .studentCode(studentProfile != null ? studentProfile.getStudentCode() : null)
                        .approvedCredits(studentProfile != null ? studentProfile.getApprovedCredits() : null)
                        .gpa(studentProfile != null ? studentProfile.getGpa() : null)
                        .semester(studentProfile != null ? studentProfile.getSemester() : null)


                        .facultyName(academicProgram.getFaculty().getName())
                        .academicProgramName(academicProgram.getName())


                        .studentModalityId(studentModality.getId())
                        .modalityName(modality.getName())
                        .modalityDescription(modality.getDescription())
                        .creditsRequired(studentModality.getProgramDegreeModality().getCreditsRequired())
                        .modalityType(studentModality.getModalityType() != null
                                ? studentModality.getModalityType().name()
                                : null)
                        .members(memberDTOs)


                        .currentStatus(status.name())
                        .currentStatusDescription(describeModalityStatus(status))
                        .selectionDate(studentModality.getSelectionDate())
                        .lastUpdatedAt(studentModality.getUpdatedAt())


                        .projectDirectorId(projectDirector != null ? projectDirector.getId() : null)
                        .projectDirectorName(projectDirector != null
                                ? projectDirector.getName() + " " + projectDirector.getLastName()
                                : null)
                        .projectDirectorEmail(projectDirector != null ? projectDirector.getEmail() : null)


                        .defenseDate(studentModality.getDefenseDate())
                        .defenseLocation(studentModality.getDefenseLocation())
                        .defenseProposedByProjectDirector(defenseProposedBy)


                        .academicDistinction(studentModality.getAcademicDistinction() != null
                                ? studentModality.getAcademicDistinction().name()
                                : null)


                        .correctionRequestDate(studentModality.getCorrectionRequestDate())
                        .correctionDeadline(studentModality.getCorrectionDeadline())
                        .correctionReminderSent(studentModality.getCorrectionReminderSent())
                        .daysRemainingForCorrection(daysRemaining)


                        .documents(documents)
                        .totalDocuments(uploadedDocuments.size())
                        .approvedDocuments((int) approvedDocs)
                        .pendingDocuments((int) pendingDocs)
                        .rejectedDocuments((int) rejectedDocs)


                        .history(history)


                        .canUploadDocuments(canUploadDocuments)
                        .canRequestCancellation(canRequestCancellation)
                        .canSubmitCorrections(canSubmitCorrections)
                        .hasDefenseScheduled(hasDefenseScheduled)
                        .requiresAction(requiresAction)

                        .build()
        );
    }

    public ResponseEntity<?> getStudentModalityDetailForProjectDirector(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User projectDirector = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        if (studentModality.getProjectDirector() == null ||
                !studentModality.getProjectDirector().getId().equals(projectDirector.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para ver esta modalidad. No es el director asignado.");
        }

        // Obtener todos los miembros activos de la modalidad
        List<StudentModalityMember> activeMembers =
            studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                studentModalityId,
                MemberStatus.ACTIVE
            );

        // Usar el líder como estudiante principal
        User student = studentModality.getLeader();

        AcademicProgram academicProgram = studentModality.getProgramDegreeModality().getAcademicProgram();

        DegreeModality modality = studentModality.getProgramDegreeModality().getDegreeModality();


        StudentProfile studentProfile = studentProfileRepository.findByUserId(student.getId())
                .orElse(null);

        List<ModalityStatusHistoryDTO> history =
                historyRepository
                        .findByStudentModalityIdOrderByChangeDateAsc(studentModalityId)
                        .stream()
                        .map(h -> ModalityStatusHistoryDTO.builder()
                                .status(h.getStatus().name())
                                .description(describeModalityStatus(h.getStatus()))
                                .changeDate(h.getChangeDate())
                                .responsible(
                                        h.getResponsible() != null
                                                ? h.getResponsible().getEmail()
                                                : "Sistema"
                                )
                                .observations(h.getObservations())
                                .build()
                        )
                        .toList();


        List<RequiredDocument> requiredDocuments =
                requiredDocumentRepository
                        .findByModalityIdAndActiveTrue(modality.getId());

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository
                        .findByStudentModalityId(studentModalityId);

        Map<Long, StudentDocument> uploadedMap =
                uploadedDocuments.stream()
                        .collect(Collectors.toMap(
                                d -> d.getDocumentConfig().getId(),
                                d -> d
                        ));

        List<DetailDocumentDTO> documents =
                requiredDocuments.stream()
                        .map(req -> {
                            StudentDocument uploaded = uploadedMap.get(req.getId());

                            return DetailDocumentDTO.builder()
                                    .studentDocumentId(
                                            uploaded != null ? uploaded.getId() : null
                                    )
                                    .documentName(req.getDocumentName())
                                    .documentType(req.getDocumentType())
                                    .uploaded(uploaded != null)
                                    .status(
                                            uploaded != null
                                                    ? uploaded.getStatus().name()
                                                    : "NOT_UPLOADED"
                                    )
                                    .statusDescription(
                                            uploaded != null
                                                    ? describeDocumentStatus(uploaded.getStatus())
                                                    : "Documento aún no cargado por el estudiante."
                                    )
                                    .notes(
                                            uploaded != null ? uploaded.getNotes() : null
                                    )
                                    .lastUpdate(
                                            uploaded != null ? uploaded.getUploadDate() : null
                                    )
                                    .build();
                        })
                        .toList();


        long approvedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();
        long pendingDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.PENDING ||
                            d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED)
                .count();
        long rejectedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                            d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();


        Long daysRemaining = null;
        if (studentModality.getCorrectionDeadline() != null) {
            daysRemaining = ChronoUnit.DAYS.between(
                    LocalDateTime.now(),
                    studentModality.getCorrectionDeadline()
            );
        }


        ModalityProcessStatus status = studentModality.getStatus();
        boolean canUploadDocuments = status == ModalityProcessStatus.MODALITY_SELECTED ||
                                    status == ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                    status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;

        boolean canRequestCancellation = status != ModalityProcessStatus.MODALITY_CLOSED &&
                                        status != ModalityProcessStatus.GRADED_APPROVED &&
                                        status != ModalityProcessStatus.GRADED_FAILED &&
                                        !status.name().startsWith("CANCELLED");

        boolean canSubmitCorrections = (status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                       status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) &&
                                      studentModality.getCorrectionDeadline() != null &&
                                      LocalDateTime.now().isBefore(studentModality.getCorrectionDeadline());

        boolean hasDefenseScheduled = studentModality.getDefenseDate() != null;

        boolean requiresAction = canUploadDocuments || canSubmitCorrections ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD ||
                                status == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE;


        String defenseProposedBy = null;
        if (status == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR) {
            defenseProposedBy = "Usted ha propuesto una fecha de sustentación. Pendiente de aprobación del comité.";
        }

        // Convertir miembros activos a DTOs
        List<ModalityMemberDTO> memberDTOs = activeMembers.stream()
                .map(member -> {
                    StudentProfile memberProfile = studentProfileRepository
                            .findByUserId(member.getStudent().getId())
                            .orElse(null);

                    return ModalityMemberDTO.builder()
                            .memberId(member.getId())
                            .studentId(member.getStudent().getId())
                            .studentName(member.getStudent().getName())
                            .studentLastName(member.getStudent().getLastName())
                            .studentEmail(member.getStudent().getEmail())
                            .studentCode(memberProfile != null ? memberProfile.getStudentCode() : null)
                            .isLeader(member.getIsLeader())
                            .status(member.getStatus().name())
                            .joinedAt(member.getJoinedAt())
                            .build();
                })
                .toList();

        return ResponseEntity.ok(
                StudentModalityDTO.builder()

                        .studentId(student.getId())
                        .studentName(student.getName())
                        .studentLastName(student.getLastName())
                        .studentEmail(student.getEmail())
                        .studentCode(studentProfile != null ? studentProfile.getStudentCode() : null)
                        .approvedCredits(studentProfile != null ? studentProfile.getApprovedCredits() : null)
                        .gpa(studentProfile != null ? studentProfile.getGpa() : null)
                        .semester(studentProfile != null ? studentProfile.getSemester() : null)


                        .facultyName(academicProgram.getFaculty().getName())
                        .academicProgramName(academicProgram.getName())


                        .studentModalityId(studentModality.getId())
                        .modalityName(modality.getName())
                        .modalityDescription(modality.getDescription())
                        .creditsRequired(studentModality.getProgramDegreeModality().getCreditsRequired())
                        .modalityType(studentModality.getModalityType() != null
                                ? studentModality.getModalityType().name()
                                : null)
                        .members(memberDTOs)


                        .currentStatus(status.name())
                        .currentStatusDescription(describeModalityStatus(status))
                        .selectionDate(studentModality.getSelectionDate())
                        .lastUpdatedAt(studentModality.getUpdatedAt())


                        .projectDirectorId(projectDirector.getId())
                        .projectDirectorName(projectDirector.getName() + " " + projectDirector.getLastName())
                        .projectDirectorEmail(projectDirector.getEmail())


                        .defenseDate(studentModality.getDefenseDate())
                        .defenseLocation(studentModality.getDefenseLocation())
                        .defenseProposedByProjectDirector(defenseProposedBy)


                        .academicDistinction(studentModality.getAcademicDistinction() != null
                                ? studentModality.getAcademicDistinction().name()
                                : null)


                        .correctionRequestDate(studentModality.getCorrectionRequestDate())
                        .correctionDeadline(studentModality.getCorrectionDeadline())
                        .correctionReminderSent(studentModality.getCorrectionReminderSent())
                        .daysRemainingForCorrection(daysRemaining)


                        .documents(documents)
                        .totalDocuments(uploadedDocuments.size())
                        .approvedDocuments((int) approvedDocs)
                        .pendingDocuments((int) pendingDocs)
                        .rejectedDocuments((int) rejectedDocs)


                        .history(history)


                        .canUploadDocuments(canUploadDocuments)
                        .canRequestCancellation(canRequestCancellation)
                        .canSubmitCorrections(canSubmitCorrections)
                        .hasDefenseScheduled(hasDefenseScheduled)
                        .requiresAction(requiresAction)

                        .build()
        );
    }

    public ResponseEntity<?> getStudentModalityDetailForExaminer(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User examiner = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        // Verificar si el usuario es un examinador asignado a esta modalidad
        DefenseExaminer defenseExaminer = defenseExaminerRepository
                .findByStudentModalityIdAndExaminerId(studentModalityId, examiner.getId())
                .orElseThrow(() -> new RuntimeException(
                        "No tiene permiso para ver esta modalidad. No está asignado como examinador."
                ));

        // Obtener todos los miembros activos de la modalidad
        List<StudentModalityMember> activeMembers =
            studentModalityMemberRepository.findByStudentModalityIdAndStatus(
                studentModalityId,
                MemberStatus.ACTIVE
            );

        AcademicProgram academicProgram = studentModality.getProgramDegreeModality().getAcademicProgram();

        // Usar el líder como estudiante principal
        User student = studentModality.getLeader();
        DegreeModality modality = studentModality.getProgramDegreeModality().getDegreeModality();

        // Información del perfil del estudiante
        StudentProfile studentProfile = studentProfileRepository.findByUserId(student.getId())
                .orElse(null);

        // Historial de estados
        List<ModalityStatusHistoryDTO> history =
                historyRepository
                        .findByStudentModalityIdOrderByChangeDateAsc(studentModalityId)
                        .stream()
                        .map(h -> ModalityStatusHistoryDTO.builder()
                                .status(h.getStatus().name())
                                .description(describeModalityStatus(h.getStatus()))
                                .changeDate(h.getChangeDate())
                                .responsible(
                                        h.getResponsible() != null
                                                ? h.getResponsible().getEmail()
                                                : "Sistema"
                                )
                                .observations(h.getObservations())
                                .build()
                        )
                        .toList();

        // Documentos requeridos y cargados
        List<RequiredDocument> requiredDocuments =
                requiredDocumentRepository
                        .findByModalityIdAndActiveTrue(modality.getId());

        List<StudentDocument> uploadedDocuments =
                studentDocumentRepository
                        .findByStudentModalityId(studentModalityId);

        Map<Long, StudentDocument> uploadedMap =
                uploadedDocuments.stream()
                        .collect(Collectors.toMap(
                                d -> d.getDocumentConfig().getId(),
                                d -> d
                        ));

        List<DetailDocumentDTO> documents =
                requiredDocuments.stream()
                        .map(req -> {
                            StudentDocument uploaded = uploadedMap.get(req.getId());

                            return DetailDocumentDTO.builder()
                                    .studentDocumentId(
                                            uploaded != null ? uploaded.getId() : null
                                    )
                                    .documentName(req.getDocumentName())
                                    .documentType(req.getDocumentType())
                                    .uploaded(uploaded != null)
                                    .status(
                                            uploaded != null
                                                    ? uploaded.getStatus().name()
                                                    : "NOT_UPLOADED"
                                    )
                                    .statusDescription(
                                            uploaded != null
                                                    ? describeDocumentStatus(uploaded.getStatus())
                                                    : "Documento aún no cargado por el estudiante."
                                    )
                                    .notes(
                                            uploaded != null ? uploaded.getNotes() : null
                                    )
                                    .lastUpdate(
                                            uploaded != null ? uploaded.getUploadDate() : null
                                    )
                                    .build();
                        })
                        .toList();

        // Estadísticas de documentos
        long approvedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();
        long pendingDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.PENDING ||
                        d.getStatus() == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW ||
                        d.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED)
                .count();
        long rejectedDocs = uploadedDocuments.stream()
                .filter(d -> d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                        d.getStatus() == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                .count();

        // Obtener todos los examinadores asignados
        List<DefenseExaminer> allExaminers = defenseExaminerRepository
                .findByStudentModalityId(studentModalityId);

        List<StudentModalityExaminerDTO.ExaminerInfo> examinersList = allExaminers.stream()
                .map(de -> {
                    // Verificar si este examinador ya evaluó
                    boolean hasEvaluated = examinerEvaluationRepository
                            .findByDefenseExaminerId(de.getId())
                            .isPresent();

                    return StudentModalityExaminerDTO.ExaminerInfo.builder()
                            .examinerId(de.getExaminer().getId())
                            .examinerName(de.getExaminer().getName() + " " + de.getExaminer().getLastName())
                            .examinerEmail(de.getExaminer().getEmail())
                            .examinerType(de.getExaminerType().name())
                            .assignmentDate(de.getAssignmentDate())
                            .hasEvaluated(hasEvaluated)
                            .build();
                })
                .toList();

        // Obtener la evaluación del examinador actual (si existe)
        StudentModalityExaminerDTO.ExaminerEvaluationInfo myEvaluationInfo = null;
        boolean hasEvaluated = false;

        ExaminerEvaluation myEvaluation = examinerEvaluationRepository
                .findByDefenseExaminerId(defenseExaminer.getId())
                .orElse(null);

        if (myEvaluation != null) {
            hasEvaluated = true;
            myEvaluationInfo = StudentModalityExaminerDTO.ExaminerEvaluationInfo.builder()
                    .evaluationId(myEvaluation.getId())
                    .grade(myEvaluation.getGrade())
                    .decision(myEvaluation.getDecision() != null ? myEvaluation.getDecision().name() : null)
                    .observations(myEvaluation.getObservations())
                    .evaluationDate(myEvaluation.getEvaluationDate())
                    .isFinalDecision(myEvaluation.getIsFinalDecision())
                    .build();
        }

        // Determinar permisos y acciones
        ModalityProcessStatus status = studentModality.getStatus();

        // El examinador puede evaluar si la defensa está programada o si es jurado de desempate y necesita evaluar
        boolean canEvaluate = (status == ModalityProcessStatus.DEFENSE_SCHEDULED && !hasEvaluated) ||
                             (defenseExaminer.getExaminerType() == ExaminerType.TIEBREAKER_EXAMINER && !hasEvaluated);

        boolean requiresAction = canEvaluate;

        boolean defenseCompleted = status == ModalityProcessStatus.GRADED_APPROVED ||
                                  status == ModalityProcessStatus.GRADED_FAILED;

        // Director del proyecto
        User projectDirector = studentModality.getProjectDirector();

        // Convertir miembros activos a DTOs
        List<ModalityMemberDTO> memberDTOs = activeMembers.stream()
                .map(member -> {
                    StudentProfile memberProfile = studentProfileRepository
                            .findByUserId(member.getStudent().getId())
                            .orElse(null);

                    return ModalityMemberDTO.builder()
                            .memberId(member.getId())
                            .studentId(member.getStudent().getId())
                            .studentName(member.getStudent().getName())
                            .studentLastName(member.getStudent().getLastName())
                            .studentEmail(member.getStudent().getEmail())
                            .studentCode(memberProfile != null ? memberProfile.getStudentCode() : null)
                            .isLeader(member.getIsLeader())
                            .status(member.getStatus().name())
                            .joinedAt(member.getJoinedAt())
                            .build();
                })
                .toList();

        return ResponseEntity.ok(
                StudentModalityExaminerDTO.builder()
                        // Información del estudiante
                        .studentId(student.getId())
                        .studentName(student.getName())
                        .studentLastName(student.getLastName())
                        .studentEmail(student.getEmail())
                        .studentCode(studentProfile != null ? studentProfile.getStudentCode() : null)
                        .approvedCredits(studentProfile != null ? studentProfile.getApprovedCredits() : null)
                        .gpa(studentProfile != null ? studentProfile.getGpa() : null)
                        .semester(studentProfile != null ? studentProfile.getSemester() : null)

                        // Información académica
                        .facultyName(academicProgram.getFaculty().getName())
                        .academicProgramName(academicProgram.getName())

                        // Información de la modalidad
                        .studentModalityId(studentModality.getId())
                        .modalityName(modality.getName())
                        .modalityDescription(modality.getDescription())
                        .creditsRequired(studentModality.getProgramDegreeModality().getCreditsRequired())
                        .modalityType(studentModality.getModalityType() != null
                                ? studentModality.getModalityType().name()
                                : null)
                        .members(memberDTOs)

                        // Estado actual
                        .currentStatus(status.name())
                        .currentStatusDescription(describeModalityStatus(status))
                        .selectionDate(studentModality.getSelectionDate())
                        .lastUpdatedAt(studentModality.getUpdatedAt())

                        // Director del proyecto
                        .projectDirectorId(projectDirector != null ? projectDirector.getId() : null)
                        .projectDirectorName(projectDirector != null
                                ? projectDirector.getName() + " " + projectDirector.getLastName()
                                : null)
                        .projectDirectorEmail(projectDirector != null ? projectDirector.getEmail() : null)

                        // Información de la defensa
                        .defenseDate(studentModality.getDefenseDate())
                        .defenseLocation(studentModality.getDefenseLocation())

                        // Examinadores
                        .examiners(examinersList)
                        .myEvaluation(myEvaluationInfo)

                        // Distinción académica y calificación final
                        .academicDistinction(studentModality.getAcademicDistinction() != null
                                ? studentModality.getAcademicDistinction().name()
                                : null)
                        .finalGrade(studentModality.getFinalGrade())

                        // Documentos
                        .documents(documents)
                        .totalDocuments(uploadedDocuments.size())
                        .approvedDocuments((int) approvedDocs)
                        .pendingDocuments((int) pendingDocs)
                        .rejectedDocuments((int) rejectedDocs)

                        // Historial
                        .history(history)

                        // Permisos y acciones
                        .canEvaluate(canEvaluate)
                        .hasEvaluated(hasEvaluated)
                        .requiresAction(requiresAction)
                        .defenseCompleted(defenseCompleted)

                        .build()
        );
    }

    public ResponseEntity<?> requestCancellation(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        // Validar que el usuario sea miembro activo de la modalidad
        boolean isActiveMember = studentModalityMemberRepository.isActiveMember(
                studentModalityId,
                student.getId()
        );

        if (!isActiveMember) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("No autorizado para solicitar cancelación de esta modalidad");
        }

        // Validar que tenga director de proyecto asignado
        if (studentModality.getProjectDirector() == null) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "No puede solicitar la cancelación aún. Debe tener un director de proyecto asignado a su modalidad antes de solicitar la cancelación."
                    )
            );
        }

        // Validar que la modalidad no esté ya en proceso de cancelación
        if (studentModality.getStatus() == ModalityProcessStatus.CANCELLATION_REQUESTED ||
                studentModality.getStatus() == ModalityProcessStatus.MODALITY_CANCELLED) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad ya tiene una solicitud de cancelación"
                    )
            );
        }

        // CORRECCIÓN CRÍTICA: Validar específicamente documento de tipo CANCELLATION
        List<StudentDocument> documents =
                studentDocumentRepository.findByStudentModalityId(studentModalityId);

        boolean hasCancellationDocument = documents.stream()
                .anyMatch(doc -> doc.getDocumentConfig().getDocumentType() == DocumentType.CANCELLATION);

        if (!hasCancellationDocument) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe subir el documento de justificación de cancelación antes de solicitar la cancelación de la modalidad"
                    )
            );
        }

        // Validar que el documento de cancelación esté en estado válido
        Optional<StudentDocument> cancellationDoc = documents.stream()
                .filter(doc -> doc.getDocumentConfig().getDocumentType() == DocumentType.CANCELLATION)
                .findFirst();

        if (cancellationDoc.isPresent()) {
            DocumentStatus docStatus = cancellationDoc.get().getStatus();
            if (docStatus == DocumentStatus.REJECTED_FOR_PROGRAM_HEAD_REVIEW ||
                docStatus == DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El documento de cancelación fue rechazado. Debe subir una nueva versión antes de solicitar la cancelación."
                        )
                );
            }
        }


        // Cambiar estado de la modalidad
        studentModality.setStatus(ModalityProcessStatus.CANCELLATION_REQUESTED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);

        // Registrar en historial
        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.CANCELLATION_REQUESTED)
                        .changeDate(LocalDateTime.now())
                        .responsible(student)
                        .observations("Solicitud de cancelación enviada por el estudiante con documento justificativo")
                        .build()
        );

        // Notificar a las partes interesadas
        notificationEventPublisher.publish(
                new CancellationRequestedEvent(studentModality.getId(), student.getId())
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "message", "Solicitud de cancelación enviada correctamente",
                        "studentModalityId", studentModalityId,
                        "newStatus", ModalityProcessStatus.CANCELLATION_REQUESTED
                )
        );
    }

    @Transactional
    public ResponseEntity<?> approveModalityCancellationByDirector(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User projectDirector = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        if (studentModality.getProjectDirector() == null ||
                !studentModality.getProjectDirector().getId().equals(projectDirector.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para aprobar la cancelación. No es el director asignado a esta modalidad");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.CANCELLATION_REQUESTED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no tiene una solicitud de cancelación pendiente",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        studentModality.setStatus(ModalityProcessStatus.CANCELLATION_APPROVED_BY_PROJECT_DIRECTOR);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.CANCELLATION_APPROVED_BY_PROJECT_DIRECTOR)
                        .changeDate(LocalDateTime.now())
                        .responsible(projectDirector)
                        .observations("El director de proyecto aprobó la solicitud de cancelación. Pendiente de revisión del comité de currículo")
                        .build()
        );


        notificationEventPublisher.publish(
                new CancellationApprovedEvent(studentModality.getId(), projectDirector.getId())
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "message", "Solicitud de cancelación aprobada. Será enviada al comité de currículo para aprobación final"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> rejectModalityCancellationByDirector(Long studentModalityId, String reason) {

        if (reason == null || reason.isBlank()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe indicar el motivo del rechazo de la cancelación"
                    )
            );
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User projectDirector = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        if (studentModality.getProjectDirector() == null ||
                !studentModality.getProjectDirector().getId().equals(projectDirector.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para rechazar la cancelación. No es el director asignado a esta modalidad");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.CANCELLATION_REQUESTED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no tiene una solicitud de cancelación pendiente",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }

        ModalityProcessStatus previousStatus = ModalityProcessStatus.PROPOSAL_APPROVED;


        List<ModalityProcessStatusHistory> history = historyRepository
                .findByStudentModalityIdOrderByChangeDateAsc(studentModalityId);

        if (history.size() >= 2) {

            previousStatus = history.get(history.size() - 2).getStatus();
        }


        studentModality.setStatus(ModalityProcessStatus.CANCELLATION_REJECTED_BY_PROJECT_DIRECTOR);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.CANCELLATION_REJECTED_BY_PROJECT_DIRECTOR)
                        .changeDate(LocalDateTime.now())
                        .responsible(projectDirector)
                        .observations("El director de proyecto rechazó la solicitud de cancelación. Motivo: " + reason)
                        .build()
        );


        studentModality.setStatus(previousStatus);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(previousStatus)
                        .changeDate(LocalDateTime.now())
                        .responsible(projectDirector)
                        .observations("Modalidad restaurada al estado anterior tras rechazo de cancelación")
                        .build()
        );


        notificationEventPublisher.publish(
                new CancellationRejectedEvent(studentModality.getId(), reason, projectDirector.getId())
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "message", "Solicitud de cancelación rechazada. La modalidad continúa en proceso normal",
                        "restoredStatus", previousStatus
                )
        );
    }

    @Transactional
    public ResponseEntity<?> approveCancellation(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality modality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        AcademicProgram academicProgram = modality.getProgramDegreeModality().getAcademicProgram();

        boolean authorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        committeeMember.getId(),
                        academicProgram.getId(),
                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para aprobar la cancelación de esta modalidad");
        }


        if (modality.getStatus() != ModalityProcessStatus.CANCELLATION_APPROVED_BY_PROJECT_DIRECTOR) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La cancelación debe ser aprobada primero por el director de proyecto",
                            "currentStatus", modality.getStatus()
                    )
            );
        }

        modality.setStatus(ModalityProcessStatus.MODALITY_CANCELLED);
        modality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(modality);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(modality)
                        .status(ModalityProcessStatus.MODALITY_CANCELLED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations("Cancelación aprobada por el comité de currículo del programa")
                        .build()
        );

        notificationEventPublisher.publish(
                new CancellationApprovedEvent(modality.getId(), committeeMember.getId())
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "message", "La modalidad fue cancelada correctamente"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> rejectCancellation(Long studentModalityId, String reason) {

        if (reason == null || reason.isBlank()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe indicar el motivo del rechazo"
                    )
            );
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality modality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        AcademicProgram academicProgram =
                modality
                        .getProgramDegreeModality()
                        .getAcademicProgram();

        boolean authorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        committeeMember.getId(),
                        academicProgram.getId(),
                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para rechazar la cancelación de esta modalidad");
        }


        if (modality.getStatus() != ModalityProcessStatus.CANCELLATION_APPROVED_BY_PROJECT_DIRECTOR) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Solo se pueden rechazar cancelaciones aprobadas por el director de proyecto",
                            "currentStatus", modality.getStatus()
                    )
            );
        }

        modality.setStatus(ModalityProcessStatus.CANCELLATION_REJECTED);
        modality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(modality);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(modality)
                        .status(ModalityProcessStatus.CANCELLATION_REJECTED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(reason)
                        .build()
        );

        notificationEventPublisher.publish(
                new CancellationRejectedEvent(
                        modality.getId(),
                        reason,
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "message", "Solicitud de cancelación rechazada correctamente"
                )
        );
    }

    public List<CancellationList> getPendingCancellations() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));


        List<Long> academicProgramIds =
                programAuthorityRepository
                        .findByUser_IdAndRole(
                                committeeMember.getId(),
                                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                        )
                        .stream()
                        .map(pa -> pa.getAcademicProgram().getId())
                        .toList();

        if (academicProgramIds.isEmpty()) {
            return List.of();
        }


        List<StudentModality> modalities =
                studentModalityRepository
                        .findByStatusAndProgramDegreeModality_AcademicProgram_IdIn(
                                ModalityProcessStatus.CANCELLATION_APPROVED_BY_PROJECT_DIRECTOR,
                                academicProgramIds
                        );

        return modalities.stream()
                .map(sm -> CancellationList.builder()
                        .studentModalityId(sm.getId())
                        .studentName(
                                sm.getLeader().getName() + " " +
                                        sm.getLeader().getLastName()
                        )
                        .email(sm.getLeader().getEmail())
                        .modalityName(
                                sm.getProgramDegreeModality()
                                        .getDegreeModality()
                                        .getName()
                        )
                        .requestDate(sm.getUpdatedAt())
                        .build()
                )
                .toList();
    }


    @Transactional
    public ResponseEntity<?> assignProjectDirector(Long studentModalityId, Long directorId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad del estudiante no encontrada"));

        User director = userRepository.findById(directorId)
                .orElseThrow(() -> new RuntimeException("Director no encontrado"));


        Long academicProgramId =
                studentModality
                        .getProgramDegreeModality()
                        .getAcademicProgram()
                        .getId();


        boolean committeeAuthorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        committeeMember.getId(),
                        academicProgramId,
                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                );

        if (!committeeAuthorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para asignar director en este programa académico");
        }


        boolean hasDirectorRole =
                director.getRoles().stream()
                        .anyMatch(role -> role.getName().equalsIgnoreCase("PROJECT_DIRECTOR"));

        if (!hasDirectorRole) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "El usuario seleccionado no tiene rol de Director de Proyecto"
                    )
            );
        }


        boolean directorAuthorized =
                programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        director.getId(),
                        academicProgramId,
                        ProgramRole.PROJECT_DIRECTOR
                );

        if (!directorAuthorized) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "El director no pertenece a este programa académico"
                    )
            );
        }


        if (studentModality.getStatus() == ModalityProcessStatus.MODALITY_SELECTED ||
                studentModality.getStatus() == ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad aún no está lista para asignar Director",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        User previousDirector = studentModality.getProjectDirector();

        studentModality.setProjectDirector(director);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);

        String observation =
                previousDirector == null
                        ? "Director asignado: " + director.getEmail()
                        : "Cambio de Director: " +
                        previousDirector.getEmail() +
                        " → " +
                        director.getEmail();

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(studentModality.getStatus())
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(observation)
                        .build()
        );

        notificationEventPublisher.publish(
                new DirectorAssignedEvent(
                        studentModality.getId(),
                        director.getId(),
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModality.getId(),
                        "directorAssigned", director.getEmail(),
                        "message", "Director asignado correctamente a la modalidad"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> proposeDefenseByDirector(Long studentModalityId, ScheduleDefenseDTO request) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User projectDirector = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        if (studentModality.getProjectDirector() == null ||
                !studentModality.getProjectDirector().getId().equals(projectDirector.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para proponer sustentación. No es el director asignado a esta modalidad");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.PROPOSAL_APPROVED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no se encuentra en estado válido para proponer sustentación",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        if (request.getDefenseDate() == null ||
                request.getDefenseLocation() == null ||
                request.getDefenseLocation().isBlank()) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe ingresar fecha y lugar válidos para la sustentación propuesta"
                    )
            );
        }


        studentModality.setDefenseDate(request.getDefenseDate());
        studentModality.setDefenseLocation(request.getDefenseLocation());
        studentModality.setStatus(ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR);
        studentModality.setUpdatedAt(LocalDateTime.now());

        studentModalityRepository.save(studentModality);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR)
                        .changeDate(LocalDateTime.now())
                        .responsible(projectDirector)
                        .observations(
                                "Director de proyecto propone sustentación para el "
                                        + request.getDefenseDate()
                                        + " en "
                                        + request.getDefenseLocation()
                        )
                        .build()
        );

        notificationEventPublisher.publish(
                new DefenseScheduledEvent(
                        studentModality.getId(),
                        request.getDefenseDate(),
                        request.getDefenseLocation(),
                        projectDirector.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModalityId,
                        "defenseDate", request.getDefenseDate(),
                        "defenseLocation", request.getDefenseLocation(),
                        "newStatus", ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR,
                        "message", "Propuesta de sustentación enviada correctamente al comité de currículo del programa"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> getPendingDefenseProposals() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<Long> academicProgramIds = programAuthorityRepository
                .findByUser_Id(committeeMember.getId())
                .stream()
                .filter(pa -> pa.getRole() == ProgramRole.PROGRAM_CURRICULUM_COMMITTEE)
                .map(pa -> pa.getAcademicProgram().getId())
                .toList();

        if (academicProgramIds.isEmpty()) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("El usuario no tiene el rol de PROGRAM_CURRICULUM_COMMITTEE");
        }


        List<StudentModality> pendingProposals = studentModalityRepository
                .findByStatusAndProgramDegreeModality_AcademicProgram_IdIn(
                        ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR,
                        academicProgramIds
                );


        List<DefenseProposalDTO> proposals = pendingProposals.stream()
                .map(sm -> {
                    User student = sm.getLeader();
                    User director = sm.getProjectDirector();


                    String studentCode = null;
                    Optional<StudentProfile> profile = studentProfileRepository.findByUserId(student.getId());
                    if (profile.isPresent()) {
                        studentCode = profile.get().getStudentCode();
                    }

                    return DefenseProposalDTO.builder()
                            .studentModalityId(sm.getId())
                            .studentName(student.getName() + " " + student.getLastName())
                            .studentEmail(student.getEmail())
                            .studentCode(studentCode)
                            .modalityName(sm.getProgramDegreeModality().getDegreeModality().getName())
                            .academicProgram(sm.getProgramDegreeModality().getAcademicProgram().getName())
                            .faculty(sm.getProgramDegreeModality().getAcademicProgram().getFaculty().getName())
                            .projectDirectorId(director != null ? director.getId() : null)
                            .projectDirectorName(director != null ? director.getName() + " " + director.getLastName() : "No asignado")
                            .projectDirectorEmail(director != null ? director.getEmail() : null)
                            .proposedDefenseDate(sm.getDefenseDate())
                            .proposedDefenseLocation(sm.getDefenseLocation())
                            .proposalSubmittedAt(sm.getUpdatedAt())
                            .currentStatus(sm.getStatus().name())
                            .statusDescription(describeModalityStatus(sm.getStatus()))
                            .build();
                })
                .toList();

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "totalProposals", proposals.size(),
                        "proposals", proposals
                )
        );
    }

    @Transactional
    public ResponseEntity<?> approveDefenseProposal(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        Long academicProgramId = studentModality
                .getProgramDegreeModality()
                .getAcademicProgram()
                .getId();


        boolean authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                committeeMember.getId(),
                academicProgramId,
                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
        );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para aprobar sustentaciones en este programa académico");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no tiene una propuesta de sustentación pendiente de aprobación",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        if (studentModality.getDefenseDate() == null ||
                studentModality.getDefenseLocation() == null ||
                studentModality.getDefenseLocation().isBlank()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "No hay fecha y lugar propuestos para aprobar"
                    )
            );
        }


        LocalDateTime approvedDate = studentModality.getDefenseDate();
        String approvedLocation = studentModality.getDefenseLocation();


        studentModality.setStatus(ModalityProcessStatus.DEFENSE_SCHEDULED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.DEFENSE_SCHEDULED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(
                                String.format(
                                        "Comité de currículo aprobó la propuesta del director de proyecto. " +
                                        "Sustentación programada para el %s en %s",
                                        approvedDate,
                                        approvedLocation
                                )
                        )
                        .build()
        );


        notificationEventPublisher.publish(
                new DefenseScheduledEvent(
                        studentModality.getId(),
                        approvedDate,
                        approvedLocation,
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModalityId,
                        "defenseDate", approvedDate,
                        "defenseLocation", approvedLocation,
                        "newStatus", ModalityProcessStatus.DEFENSE_SCHEDULED,
                        "action", "APROBADA",
                        "message", "Propuesta de sustentación aprobada correctamente"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> rescheduleDefense(Long studentModalityId, ScheduleDefenseDTO request) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        Long academicProgramId = studentModality
                .getProgramDegreeModality()
                .getAcademicProgram()
                .getId();


        boolean authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                committeeMember.getId(),
                academicProgramId,
                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
        );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para reprogramar sustentaciones en este programa académico");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR &&
                studentModality.getStatus() != ModalityProcessStatus.PROPOSAL_APPROVED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no se encuentra en estado válido para reprogramar sustentación",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        if (request.getDefenseDate() == null ||
                request.getDefenseLocation() == null ||
                request.getDefenseLocation().isBlank()) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe ingresar fecha y lugar válidos para la reprogramación"
                    )
            );
        }


        LocalDateTime originalProposedDate = studentModality.getDefenseDate();
        String originalProposedLocation = studentModality.getDefenseLocation();
        boolean hadProposal = studentModality.getStatus() == ModalityProcessStatus.DEFENSE_REQUESTED_BY_PROJECT_DIRECTOR;


        studentModality.setDefenseDate(request.getDefenseDate());
        studentModality.setDefenseLocation(request.getDefenseLocation());
        studentModality.setStatus(ModalityProcessStatus.DEFENSE_SCHEDULED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        String observation;
        if (hadProposal && originalProposedDate != null && originalProposedLocation != null) {
            observation = String.format(
                    "Comité de currículo reprogramó la sustentación. " +
                    "Propuesta original del director: %s en %s. " +
                    "Nueva programación: %s en %s",
                    originalProposedDate,
                    originalProposedLocation,
                    request.getDefenseDate(),
                    request.getDefenseLocation()
            );
        } else {
            observation = String.format(
                    "Comité de currículo programó la sustentación para el %s en %s",
                    request.getDefenseDate(),
                    request.getDefenseLocation()
            );
        }


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.DEFENSE_SCHEDULED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(observation)
                        .build()
        );


        notificationEventPublisher.publish(
                new DefenseScheduledEvent(
                        studentModality.getId(),
                        request.getDefenseDate(),
                        request.getDefenseLocation(),
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModalityId,
                        "defenseDate", request.getDefenseDate(),
                        "defenseLocation", request.getDefenseLocation(),
                        "newStatus", ModalityProcessStatus.DEFENSE_SCHEDULED,
                        "action", hadProposal ? "REPROGRAMADA" : "PROGRAMADA",
                        "hadProposal", hadProposal,
                        "message", hadProposal ? "Sustentación reprogramada correctamente" : "Sustentación programada correctamente"
                )
        );
    }

    @Transactional
    public ResponseEntity<?> assignExaminers(Long studentModalityId, ScheduleDefenseDTO request) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        Long academicProgramId = studentModality
                .getProgramDegreeModality()
                .getAcademicProgram()
                .getId();


        boolean authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                committeeMember.getId(),
                academicProgramId,
                ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
        );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tiene permiso para asignar jueces en este programa académico"
                    ));
        }


        if (studentModality.getDefenseDate() == null || studentModality.getDefenseLocation() == null) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe programar primero la fecha y lugar de la sustentación antes de asignar jueces"
                    )
            );
        }


        if (studentModality.getStatus() != ModalityProcessStatus.DEFENSE_SCHEDULED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad debe estar en estado 'SUSTENTACIÓN PROGRAMADA' para asignar jueces",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        if (request.getPrimaryExaminer1Id() == null &&
                request.getPrimaryExaminer2Id() == null &&
                request.getTiebreakerExaminerId() == null) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe proporcionar al menos un juez para asignar"
                    )
            );
        }


        List<Long> examinerIds = new ArrayList<>();
        if (request.getPrimaryExaminer1Id() != null) examinerIds.add(request.getPrimaryExaminer1Id());
        if (request.getPrimaryExaminer2Id() != null) examinerIds.add(request.getPrimaryExaminer2Id());
        if (request.getTiebreakerExaminerId() != null) examinerIds.add(request.getTiebreakerExaminerId());


        Set<Long> uniqueIds = new HashSet<>(examinerIds);
        if (uniqueIds.size() != examinerIds.size()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "No se pueden asignar el mismo juez más de una vez"
                    )
            );
        }

        List<String> examinerAssignmentMessages = new ArrayList<>();


        if (request.getPrimaryExaminer1Id() != null) {
            User examiner1 = userRepository.findById(request.getPrimaryExaminer1Id())
                    .orElseThrow(() -> new RuntimeException("Juez principal 1 no encontrado"));


            boolean hasExaminerRole = examiner1.getRoles().stream()
                    .anyMatch(role -> role.getName().equals("EXAMINER"));

            if (!hasExaminerRole) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El usuario seleccionado como juez principal 1 no tiene el rol EXAMINER"
                        )
                );
            }


            boolean examiner1Authorized = programAuthorityRepository
                    .existsByUser_IdAndAcademicProgram_Id(
                            examiner1.getId(),
                            academicProgramId
                    );

            if (!examiner1Authorized) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El juez principal 1 no está asociado al programa académico de la modalidad"
                        )
                );
            }


            if (studentModality.getProjectDirector() != null &&
                    studentModality.getProjectDirector().getId().equals(examiner1.getId())) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El director del proyecto no puede ser juez de la misma modalidad"
                        )
                );
            }


            defenseExaminerRepository
                    .findByStudentModalityIdAndExaminerType(studentModalityId, ExaminerType.PRIMARY_EXAMINER_1)
                    .ifPresent(defenseExaminerRepository::delete);


            DefenseExaminer defenseExaminer = DefenseExaminer.builder()
                    .studentModality(studentModality)
                    .examiner(examiner1)
                    .examinerType(ExaminerType.PRIMARY_EXAMINER_1)
                    .assignmentDate(LocalDateTime.now())
                    .assignedBy(committeeMember)
                    .build();

            defenseExaminerRepository.save(defenseExaminer);
            examinerAssignmentMessages.add("Juez Principal 1: " + examiner1.getName() + " " + examiner1.getLastName());
        }


        if (request.getPrimaryExaminer2Id() != null) {
            User examiner2 = userRepository.findById(request.getPrimaryExaminer2Id())
                    .orElseThrow(() -> new RuntimeException("Juez principal 2 no encontrado"));


            boolean hasExaminerRole = examiner2.getRoles().stream()
                    .anyMatch(role -> role.getName().equals("EXAMINER"));

            if (!hasExaminerRole) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El usuario seleccionado como juez principal 2 no tiene el rol EXAMINER"
                        )
                );
            }


            boolean examiner2Authorized = programAuthorityRepository
                    .existsByUser_IdAndAcademicProgram_Id(
                            examiner2.getId(),
                            academicProgramId
                    );

            if (!examiner2Authorized) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El juez principal 2 no está asociado al programa académico de la modalidad"
                        )
                );
            }


            if (studentModality.getProjectDirector() != null &&
                    studentModality.getProjectDirector().getId().equals(examiner2.getId())) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El director del proyecto no puede ser juez de la misma modalidad"
                        )
                );
            }


            defenseExaminerRepository
                    .findByStudentModalityIdAndExaminerType(studentModalityId, ExaminerType.PRIMARY_EXAMINER_2)
                    .ifPresent(defenseExaminerRepository::delete);


            DefenseExaminer defenseExaminer = DefenseExaminer.builder()
                    .studentModality(studentModality)
                    .examiner(examiner2)
                    .examinerType(ExaminerType.PRIMARY_EXAMINER_2)
                    .assignmentDate(LocalDateTime.now())
                    .assignedBy(committeeMember)
                    .build();

            defenseExaminerRepository.save(defenseExaminer);
            examinerAssignmentMessages.add("Juez Principal 2: " + examiner2.getName() + " " + examiner2.getLastName());
        }


        if (request.getTiebreakerExaminerId() != null) {
            User examiner3 = userRepository.findById(request.getTiebreakerExaminerId())
                    .orElseThrow(() -> new RuntimeException("Juez de desempate no encontrado"));


            boolean hasExaminerRole = examiner3.getRoles().stream()
                    .anyMatch(role -> role.getName().equals("EXAMINER"));

            if (!hasExaminerRole) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El usuario seleccionado como juez de desempate no tiene el rol EXAMINER"
                        )
                );
            }


            boolean examiner3Authorized = programAuthorityRepository
                    .existsByUser_IdAndAcademicProgram_Id(
                            examiner3.getId(),
                            academicProgramId
                    );

            if (!examiner3Authorized) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El juez de desempate no está asociado al programa académico de la modalidad"
                        )
                );
            }


            if (studentModality.getProjectDirector() != null &&
                    studentModality.getProjectDirector().getId().equals(examiner3.getId())) {
                return ResponseEntity.badRequest().body(
                        Map.of(
                                "success", false,
                                "message", "El director del proyecto no puede ser juez de la misma modalidad"
                        )
                );
            }


            defenseExaminerRepository
                    .findByStudentModalityIdAndExaminerType(studentModalityId, ExaminerType.TIEBREAKER_EXAMINER)
                    .ifPresent(defenseExaminerRepository::delete);


            DefenseExaminer defenseExaminer = DefenseExaminer.builder()
                    .studentModality(studentModality)
                    .examiner(examiner3)
                    .examinerType(ExaminerType.TIEBREAKER_EXAMINER)
                    .assignmentDate(LocalDateTime.now())
                    .assignedBy(committeeMember)
                    .build();

            defenseExaminerRepository.save(defenseExaminer);
            examinerAssignmentMessages.add("Juez de Desempate: " + examiner3.getName() + " " + examiner3.getLastName());
        }



        studentModality.setStatus(ModalityProcessStatus.EXAMINERS_ASSIGNED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);

        String observationMessage = "Jueces asignados por el comité de currículo:\n" +
                String.join("\n", examinerAssignmentMessages);

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.EXAMINERS_ASSIGNED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(observationMessage)
                        .build()
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModalityId,
                        "newStatus", ModalityProcessStatus.EXAMINERS_ASSIGNED,
                        "examinersAssigned", examinerAssignmentMessages,
                        "message", "Jueces asignados correctamente a la sustentación"
                )
        );
    }


    @Transactional
    public ResponseEntity<?> registerFinalDefenseEvaluation(Long studentModalityId, ExaminerEvaluationDTO evaluationDTO) {


        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User examiner = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        DefenseExaminer defenseExaminer = defenseExaminerRepository
                .findByStudentModalityIdAndExaminerId(studentModalityId, examiner.getId())
                .orElseThrow(() -> new RuntimeException(
                        "No está asignado como juez de esta sustentación"
                ));


        if (examinerEvaluationRepository.existsByDefenseExaminerId(defenseExaminer.getId())) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Ya ha registrado su evaluación para esta sustentación"
                    )
            );
        }


        if (studentModality.getStatus() != ModalityProcessStatus.DEFENSE_COMPLETED &&
                studentModality.getStatus() != ModalityProcessStatus.READY_FOR_DEFENSE &&
                studentModality.getStatus() != ModalityProcessStatus.EXAMINERS_ASSIGNED &&
                studentModality.getStatus() != ModalityProcessStatus.UNDER_EVALUATION_PRIMARY_EXAMINERS &&
                studentModality.getStatus() != ModalityProcessStatus.UNDER_EVALUATION_TIEBREAKER &&
                studentModality.getStatus() != ModalityProcessStatus.DISAGREEMENT_REQUIRES_TIEBREAKER) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad no está en estado válido para registrar evaluaciones",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        if (!isGradeConsistentWithDecision(evaluationDTO.getGrade(), evaluationDTO.getDecision())) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La calificación no es consistente con la decisión tomada"
                    )
            );
        }


        ExaminerEvaluation evaluation = ExaminerEvaluation.builder()
                .defenseExaminer(defenseExaminer)
                .grade(evaluationDTO.getGrade())
                .decision(evaluationDTO.getDecision())
                .observations(evaluationDTO.getObservations())
                .evaluationDate(LocalDateTime.now())
                .isFinalDecision(false)
                .build();

        examinerEvaluationRepository.save(evaluation);


        if (defenseExaminer.getExaminerType() == ExaminerType.TIEBREAKER_EXAMINER) {

            return processTiebreakerEvaluation(studentModality, evaluation, examiner);
        } else {

            return processPrimaryExaminerEvaluation(studentModality, evaluation, examiner);
        }
    }


    private boolean isGradeConsistentWithDecision(Double grade, ExaminerDecision decision) {
        return switch (decision) {
            case REJECTED -> grade < 3.0;
            case APPROVED_NO_DISTINCTION -> grade >= 3.0 && grade < 4.0;
            case APPROVED_MERITORIOUS -> grade >= 4.0 && grade < 4.5;
            case APPROVED_LAUREATE -> grade >= 4.5 && grade <= 5.0;
        };
    }


    private ResponseEntity<?> processPrimaryExaminerEvaluation(
            StudentModality studentModality,
            ExaminerEvaluation currentEvaluation,
            User examiner) {


        if (studentModality.getStatus() == ModalityProcessStatus.DEFENSE_COMPLETED) {
            studentModality.setStatus(ModalityProcessStatus.UNDER_EVALUATION_PRIMARY_EXAMINERS);
            studentModality.setUpdatedAt(LocalDateTime.now());
            studentModalityRepository.save(studentModality);
        }


        boolean bothEvaluated = examinerEvaluationRepository
                .bothPrimaryExaminersHaveEvaluated(studentModality.getId());

        if (!bothEvaluated) {

            historyRepository.save(
                    ModalityProcessStatusHistory.builder()
                            .studentModality(studentModality)
                            .status(ModalityProcessStatus.UNDER_EVALUATION_PRIMARY_EXAMINERS)
                            .changeDate(LocalDateTime.now())
                            .responsible(examiner)
                            .observations("Juez " + examiner.getName() + " ha registrado su evaluación. " +
                                    "Calificación: " + currentEvaluation.getGrade() +
                                    ". Decisión: " + currentEvaluation.getDecision())
                            .build()
            );

            return ResponseEntity.ok(
                    Map.of(
                            "success", true,
                            "message", "Evaluación registrada correctamente. Esperando evaluación del otro juez principal.",
                            "grade", currentEvaluation.getGrade(),
                            "decision", currentEvaluation.getDecision()
                    )
            );
        }


        List<ExaminerEvaluation> primaryEvaluations = examinerEvaluationRepository
                .findPrimaryEvaluationsByStudentModalityId(studentModality.getId());

        boolean hasConsensus = examinerEvaluationRepository
                .primaryExaminersHaveConsensus(studentModality.getId());

        if (hasConsensus) {

            return applyFinalResultWithConsensus(studentModality, primaryEvaluations, examiner);
        } else {

            return requestTiebreakerExaminer(studentModality, primaryEvaluations, examiner);
        }
    }


    private ResponseEntity<?> applyFinalResultWithConsensus(
            StudentModality studentModality,
            List<ExaminerEvaluation> primaryEvaluations,
            User examiner) {

        ExaminerDecision consensusDecision = primaryEvaluations.get(0).getDecision();


        Double averageGrade = examinerEvaluationRepository
                .calculateAverageGradeOfPrimaryExaminers(studentModality.getId());


        primaryEvaluations.forEach(eval -> {
            eval.setIsFinalDecision(true);
            examinerEvaluationRepository.save(eval);
        });


        AcademicDistinction distinction;
        ModalityProcessStatus finalStatus;

        if (consensusDecision == ExaminerDecision.REJECTED) {
            distinction = AcademicDistinction.AGREED_REJECTED;
            finalStatus = ModalityProcessStatus.GRADED_FAILED;
        } else {
            finalStatus = ModalityProcessStatus.GRADED_APPROVED;
            distinction = switch (consensusDecision) {
                case APPROVED_NO_DISTINCTION -> AcademicDistinction.AGREED_APPROVED;
                case APPROVED_MERITORIOUS -> AcademicDistinction.AGREED_MERITORIOUS;
                case APPROVED_LAUREATE -> AcademicDistinction.AGREED_LAUREATE;
                default -> AcademicDistinction.NO_DISTINCTION;
            };
        }


        studentModality.setStatus(finalStatus);
        studentModality.setAcademicDistinction(distinction);
        studentModality.setFinalGrade(averageGrade);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        String observations = String.format(
                "CONSENSO entre jueces principales. Calificación final: %.2f. " +
                "Decisión: %s. Distinción: %s",
                averageGrade, consensusDecision, distinction
        );

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(finalStatus)
                        .changeDate(LocalDateTime.now())
                        .responsible(examiner)
                        .observations(observations)
                        .build()
        );


        notificationEventPublisher.publish(
                new FinalDefenseResultEvent(
                        studentModality.getId(),
                        finalStatus,
                        distinction,
                        observations,
                        examiner.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "hasConsensus", true,
                        "finalStatus", finalStatus,
                        "academicDistinction", distinction,
                        "finalGrade", averageGrade,
                        "message", finalStatus == ModalityProcessStatus.GRADED_APPROVED
                                ? "Modalidad APROBADA por consenso de los jueces"
                                : "Modalidad REPROBADA por consenso de los jueces"
                )
        );
    }

    private ResponseEntity<?> requestTiebreakerExaminer(
            StudentModality studentModality,
            List<ExaminerEvaluation> primaryEvaluations,
            User examiner) {


        studentModality.setStatus(ModalityProcessStatus.DISAGREEMENT_REQUIRES_TIEBREAKER);
        studentModality.setAcademicDistinction(AcademicDistinction.DISAGREEMENT_PENDING_TIEBREAKER);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        String observations = String.format(
                "DESACUERDO entre jueces principales. Juez 1: %s (%.2f). Juez 2: %s (%.2f). " +
                "Se requiere asignar un tercer juez para desempatar.",
                primaryEvaluations.get(0).getDecision(), primaryEvaluations.get(0).getGrade(),
                primaryEvaluations.get(1).getDecision(), primaryEvaluations.get(1).getGrade()
        );

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.DISAGREEMENT_REQUIRES_TIEBREAKER)
                        .changeDate(LocalDateTime.now())
                        .responsible(examiner)
                        .observations(observations)
                        .build()
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "hasConsensus", false,
                        "requiresTiebreaker", true,
                        "status", ModalityProcessStatus.DISAGREEMENT_REQUIRES_TIEBREAKER,
                        "message", "No hay consenso entre los jueces principales. Se requiere asignar un tercer juez para desempatar."
                )
        );
    }


    private ResponseEntity<?> processTiebreakerEvaluation(
            StudentModality studentModality,
            ExaminerEvaluation tiebreakerEvaluation,
            User examiner) {


        tiebreakerEvaluation.setIsFinalDecision(true);
        examinerEvaluationRepository.save(tiebreakerEvaluation);


        ExaminerDecision tiebreakerDecision = tiebreakerEvaluation.getDecision();
        AcademicDistinction distinction;
        ModalityProcessStatus finalStatus;

        if (tiebreakerDecision == ExaminerDecision.REJECTED) {
            distinction = AcademicDistinction.TIEBREAKER_REJECTED;
            finalStatus = ModalityProcessStatus.GRADED_FAILED;
        } else {
            finalStatus = ModalityProcessStatus.GRADED_APPROVED;
            distinction = switch (tiebreakerDecision) {
                case APPROVED_NO_DISTINCTION -> AcademicDistinction.TIEBREAKER_APPROVED;
                case APPROVED_MERITORIOUS -> AcademicDistinction.TIEBREAKER_MERITORIOUS;
                case APPROVED_LAUREATE -> AcademicDistinction.TIEBREAKER_LAUREATE;
                default -> AcademicDistinction.NO_DISTINCTION;
            };
        }


        studentModality.setStatus(finalStatus);
        studentModality.setAcademicDistinction(distinction);
        studentModality.setFinalGrade(tiebreakerEvaluation.getGrade());
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        String observations = String.format(
                "DESEMPATE resuelto por tercer juez. Calificación final: %.2f. " +
                "Decisión: %s. Distinción: %s",
                tiebreakerEvaluation.getGrade(), tiebreakerDecision, distinction
        );

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(finalStatus)
                        .changeDate(LocalDateTime.now())
                        .responsible(examiner)
                        .observations(observations)
                        .build()
        );


        notificationEventPublisher.publish(
                new FinalDefenseResultEvent(
                        studentModality.getId(),
                        finalStatus,
                        distinction,
                        observations,
                        examiner.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "isTiebreaker", true,
                        "finalStatus", finalStatus,
                        "academicDistinction", distinction,
                        "finalGrade", tiebreakerEvaluation.getGrade(),
                        "message", finalStatus == ModalityProcessStatus.GRADED_APPROVED
                                ? "Modalidad APROBADA por decisión del juez de desempate"
                                : "Modalidad REPROBADA por decisión del juez de desempate"
                )
        );
    }

    public ResponseEntity<?> getFinalDefenseResult(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        Long academicProgramId =
                studentModality
                        .getProgramDegreeModality()
                        .getAcademicProgram()
                        .getId();


        boolean authorized =
                programAuthorityRepository
                        .existsByUser_IdAndAcademicProgram_IdAndRoleIn(
                                user.getId(),
                                academicProgramId,
                                List.of(
                                        ProgramRole.PROGRAM_HEAD,
                                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                                )
                        );

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("No tiene permiso para consultar el resultado final de esta modalidad");
        }


        if (studentModality.getStatus() != ModalityProcessStatus.GRADED_APPROVED &&
                studentModality.getStatus() != ModalityProcessStatus.GRADED_FAILED) {

            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad aún no tiene un resultado final registrado",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }

        ModalityProcessStatus finalStatus = studentModality.getStatus();

        ModalityProcessStatusHistory history =
                historyRepository
                        .findTopByStudentModalityAndStatusOrderByChangeDateDesc(
                                studentModality,
                                finalStatus
                        )
                        .orElseThrow(() ->
                                new RuntimeException("No se encontró historial de evaluación final")
                        );


        List<DefenseExaminer> defenseExaminers = defenseExaminerRepository
                .findByStudentModalityId(studentModalityId);

        List<FinalDefenseResponse.ExaminerEvaluationDetail> examinerEvaluations = defenseExaminers.stream()
                .map(defenseExaminer -> {
                    ExaminerEvaluation evaluation = examinerEvaluationRepository
                            .findByDefenseExaminerId(defenseExaminer.getId())
                            .orElse(null);

                    if (evaluation == null) {
                        return null;
                    }

                    return FinalDefenseResponse.ExaminerEvaluationDetail.builder()
                            .examinerName(defenseExaminer.getExaminer().getName() + " " +
                                        defenseExaminer.getExaminer().getLastName())
                            .examinerType(defenseExaminer.getExaminerType().name())
                            .grade(evaluation.getGrade())
                            .decision(evaluation.getDecision())
                            .observations(evaluation.getObservations())
                            .evaluationDate(evaluation.getEvaluationDate())
                            .isFinalDecision(evaluation.getIsFinalDecision())
                            .build();
                })
                .filter(detail -> detail != null)
                .toList();


        boolean hasConsensus = studentModality.getAcademicDistinction() != null &&
                              (studentModality.getAcademicDistinction().name().startsWith("AGREED_"));

        boolean wasTiebreaker = studentModality.getAcademicDistinction() != null &&
                               (studentModality.getAcademicDistinction().name().startsWith("TIEBREAKER_"));

        return ResponseEntity.ok(
                FinalDefenseResponse.builder()
                        .studentModalityId(studentModality.getId())
                        .studentName(
                                studentModality.getLeader().getName() + " " +
                                        studentModality.getLeader().getLastName()
                        )
                        .studentEmail(studentModality.getLeader().getEmail())
                        .finalStatus(finalStatus)
                        .approved(finalStatus == ModalityProcessStatus.GRADED_APPROVED)
                        .academicDistinction(studentModality.getAcademicDistinction())
                        .finalGrade(studentModality.getFinalGrade())
                        .observations(history.getObservations())
                        .evaluationDate(history.getChangeDate())
                        .evaluatedBy(
                                history.getResponsible() != null
                                        ? history.getResponsible().getName()
                                        : "Comité de currículo de programa"
                        )
                        .hasConsensus(hasConsensus)
                        .wasTiebreaker(wasTiebreaker)
                        .examinerEvaluations(examinerEvaluations)
                        .build()
        );
    }

    public ResponseEntity<?> getMyFinalDefenseResult() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository
                .findByStudent(student)
                .orElseThrow(() -> new RuntimeException(
                        "No se encontró una modalidad asociada al estudiante"
                ));

        if (studentModality.getStatus() != ModalityProcessStatus.GRADED_APPROVED &&
                studentModality.getStatus() != ModalityProcessStatus.GRADED_FAILED) {

            return ResponseEntity.ok(
                    Map.of(
                            "hasResult", false,
                            "message", "Tu modalidad aún no tiene un resultado final"
                    )
            );
        }

        ModalityProcessStatus finalStatus = studentModality.getStatus();

        ModalityProcessStatusHistory history = historyRepository
                .findTopByStudentModalityAndStatusOrderByChangeDateDesc(
                        studentModality,
                        finalStatus
                )
                .orElseThrow(() -> new RuntimeException(
                        "No se encontró historial de evaluación final"
                ));


        List<DefenseExaminer> defenseExaminers = defenseExaminerRepository
                .findByStudentModalityId(studentModality.getId());

        List<FinalDefenseResponse.ExaminerEvaluationDetail> examinerEvaluations = defenseExaminers.stream()
                .map(defenseExaminer -> {
                    ExaminerEvaluation evaluation = examinerEvaluationRepository
                            .findByDefenseExaminerId(defenseExaminer.getId())
                            .orElse(null);

                    if (evaluation == null) {
                        return null;
                    }

                    return FinalDefenseResponse.ExaminerEvaluationDetail.builder()
                            .examinerName(defenseExaminer.getExaminer().getName() + " " +
                                        defenseExaminer.getExaminer().getLastName())
                            .examinerType(defenseExaminer.getExaminerType().name())
                            .grade(evaluation.getGrade())
                            .decision(evaluation.getDecision())
                            .observations(evaluation.getObservations())
                            .evaluationDate(evaluation.getEvaluationDate())
                            .isFinalDecision(evaluation.getIsFinalDecision())
                            .build();
                })
                .filter(detail -> detail != null)
                .toList();


        boolean hasConsensus = studentModality.getAcademicDistinction() != null &&
                              (studentModality.getAcademicDistinction().name().startsWith("AGREED_"));

        boolean wasTiebreaker = studentModality.getAcademicDistinction() != null &&
                               (studentModality.getAcademicDistinction().name().startsWith("TIEBREAKER_"));

        return ResponseEntity.ok(
                FinalDefenseResponse.builder()
                        .studentModalityId(studentModality.getId())
                        .studentName(student.getName() + " " + student.getLastName())
                        .studentEmail(student.getEmail())
                        .finalStatus(finalStatus)
                        .approved(finalStatus == ModalityProcessStatus.GRADED_APPROVED)
                        .academicDistinction(studentModality.getAcademicDistinction())
                        .finalGrade(studentModality.getFinalGrade())
                        .observations(history.getObservations())
                        .evaluationDate(history.getChangeDate())
                        .evaluatedBy(
                                history.getResponsible() != null
                                        ? history.getResponsible().getName()
                                        : "Comité de currículo de programa"
                        )
                        .hasConsensus(hasConsensus)
                        .wasTiebreaker(wasTiebreaker)
                        .examinerEvaluations(examinerEvaluations)
                        .build()
        );
    }

    public List<ProjectDirectorResponse> getProjectDirectors() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User currentUser = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<ProgramAuthority> committeeAuthorities = programAuthorityRepository
                .findByUser_IdAndRole(currentUser.getId(), ProgramRole.PROGRAM_CURRICULUM_COMMITTEE);

        if (committeeAuthorities.isEmpty()) {
            throw new RuntimeException("El usuario no tiene el rol de PROGRAM_CURRICULUM_COMMITTEE");
        }


        Set<Long> userProgramIds = committeeAuthorities.stream()
                .map(authority -> authority.getAcademicProgram().getId())
                .collect(Collectors.toSet());


        List<com.SIGMA.USCO.Users.Entity.ProgramAuthority> projectDirectorAuthorities = programAuthorityRepository
                .findByAcademicProgram_IdAndRole(userProgramIds.iterator().next(),
                        ProgramRole.PROJECT_DIRECTOR
                );


        return projectDirectorAuthorities.stream()
                .map(authority -> new ProjectDirectorResponse(
                        authority.getUser().getId(),
                        authority.getUser().getName(),
                        authority.getUser().getLastName(),
                        authority.getUser().getEmail()
                ))
                .distinct()
                .collect(Collectors.toList());
    }

    public List<ProjectDirectorResponse> getProgramHeads() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User currentUser = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<ProgramAuthority> committeeAuthorities = programAuthorityRepository
                .findByUser_IdAndRole(currentUser.getId(), ProgramRole.PROGRAM_CURRICULUM_COMMITTEE);

        if (committeeAuthorities.isEmpty()) {
            throw new RuntimeException("El usuario no tiene el rol de PROGRAM_CURRICULUM_COMMITTEE");
        }


        Set<Long> userProgramIds = committeeAuthorities.stream()
                .map(authority -> authority.getAcademicProgram().getId())
                .collect(Collectors.toSet());


        List<com.SIGMA.USCO.Users.Entity.ProgramAuthority> programHeadAuthorities = programAuthorityRepository
                .findByAcademicProgram_IdAndRole(userProgramIds.iterator().next(),
                        ProgramRole.PROGRAM_HEAD
                );


        return programHeadAuthorities.stream()
                .map(authority -> new ProjectDirectorResponse(
                        authority.getUser().getId(),
                        authority.getUser().getName(),
                        authority.getUser().getLastName(),
                        authority.getUser().getEmail()
                ))
                .distinct()
                .collect(Collectors.toList());
    }

    public List<ProjectDirectorResponse> getProgramCurriculumCommittee(Long academicProgramId, Long facultyId) {


        List<ProgramAuthority> committeeAuthorities = programAuthorityRepository.findAll()
                .stream()
                .filter(authority -> authority.getRole() == ProgramRole.PROGRAM_CURRICULUM_COMMITTEE)
                .toList();


        if (academicProgramId != null) {
            committeeAuthorities = committeeAuthorities.stream()
                    .filter(authority -> authority.getAcademicProgram().getId().equals(academicProgramId))
                    .toList();
        }

        if (facultyId != null) {
            committeeAuthorities = committeeAuthorities.stream()
                    .filter(authority -> authority.getAcademicProgram().getFaculty().getId().equals(facultyId))
                    .toList();
        }


        return committeeAuthorities.stream()
                .map(authority -> new ProjectDirectorResponse(
                        authority.getUser().getId(),
                        authority.getUser().getName(),
                        authority.getUser().getLastName(),
                        authority.getUser().getEmail()
                ))
                .distinct()
                .collect(Collectors.toList());
    }


    public List<ProjectDirectorResponse> getExaminers(Long academicProgramId, Long facultyId) {


        List<User> examiners = userRepository.findAll()
                .stream()
                .filter(user -> user.getRoles().stream()
                        .anyMatch(role -> role.getName().equals("EXAMINER")))
                .toList();


        if (academicProgramId != null || facultyId != null) {
            List<ProgramAuthority> examinerAuthorities = programAuthorityRepository.findAll()
                    .stream()
                    .filter(authority -> examiners.stream()
                            .anyMatch(examiner -> examiner.getId().equals(authority.getUser().getId())))
                    .toList();

            if (academicProgramId != null) {
                examinerAuthorities = examinerAuthorities.stream()
                        .filter(authority -> authority.getAcademicProgram().getId().equals(academicProgramId))
                        .toList();
            }

            if (facultyId != null) {
                examinerAuthorities = examinerAuthorities.stream()
                        .filter(authority -> authority.getAcademicProgram().getFaculty().getId().equals(facultyId))
                        .toList();
            }

            return examinerAuthorities.stream()
                    .map(authority -> new ProjectDirectorResponse(
                            authority.getUser().getId(),
                            authority.getUser().getName(),
                            authority.getUser().getLastName(),
                            authority.getUser().getEmail()
                    ))
                    .distinct()
                    .collect(Collectors.toList());
        }


        return examiners.stream()
                .map(examiner -> new ProjectDirectorResponse(
                        examiner.getId(),
                        examiner.getName(),
                        examiner.getLastName(),
                        examiner.getEmail()
                ))
                .distinct()
                .collect(Collectors.toList());
    }


    public List<ProjectDirectorResponse> getExaminersForCommittee() {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User currentUser = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));


        List<ProgramAuthority> committeeAuthorities = programAuthorityRepository
                .findByUser_IdAndRole(currentUser.getId(), ProgramRole.PROGRAM_CURRICULUM_COMMITTEE);

        if (committeeAuthorities.isEmpty()) {
            throw new RuntimeException("El usuario no tiene el rol de PROGRAM_CURRICULUM_COMMITTEE");
        }


        Set<Long> userProgramIds = committeeAuthorities.stream()
                .map(authority -> authority.getAcademicProgram().getId())
                .collect(Collectors.toSet());


        List<User> allExaminers = userRepository.findAll()
                .stream()
                .filter(user -> user.getRoles().stream()
                        .anyMatch(role -> role.getName().equals("EXAMINER")))
                .toList();


        List<ProgramAuthority> examinerAuthorities = new ArrayList<>();

        for (Long programId : userProgramIds) {
            List<ProgramAuthority> programExaminers = programAuthorityRepository.findAll()
                    .stream()
                    .filter(authority -> authority.getAcademicProgram().getId().equals(programId))
                    .filter(authority -> allExaminers.stream()
                            .anyMatch(examiner -> examiner.getId().equals(authority.getUser().getId())))
                    .toList();

            examinerAuthorities.addAll(programExaminers);
        }


        return examinerAuthorities.stream()
                .map(authority -> new ProjectDirectorResponse(
                        authority.getUser().getId(),
                        authority.getUser().getName(),
                        authority.getUser().getLastName(),
                        authority.getUser().getEmail()
                ))
                .distinct()
                .collect(Collectors.toList());
    }


    @Transactional
    public ResponseEntity<?> resubmitCorrectedDocument(Long studentModalityId, Long documentId, MultipartFile file) throws IOException {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User student = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        // Validar que el usuario sea miembro activo de la modalidad
        boolean isActiveMember = studentModalityMemberRepository.isActiveMember(
                studentModalityId,
                student.getId()
        );

        if (!isActiveMember) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tienes permiso para modificar esta modalidad"
                    ));
        }


        if (studentModality.getStatus() != ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD &&
                studentModality.getStatus() != ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) {
            return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "message", "La modalidad no está en estado de correcciones solicitadas",
                    "currentStatus", studentModality.getStatus()
            ));
        }


        if (studentModality.getCorrectionDeadline() != null &&
                LocalDateTime.now().isAfter(studentModality.getCorrectionDeadline())) {
            return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "message", "El plazo de 30 días para entregar las correcciones ha vencido. La modalidad ha sido cancelada.",
                    "deadline", studentModality.getCorrectionDeadline()
            ));
        }


        StudentDocument document = studentDocumentRepository.findById(documentId)
                .orElseThrow(() -> new RuntimeException("Documento no encontrado"));


        if (!document.getStudentModality().getId().equals(studentModalityId)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "El documento no pertenece a esta modalidad"
                    ));
        }


        if (document.getStatus() != DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD &&
                document.getStatus() != DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_CURRICULUM_COMMITTEE) {
            return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "message", "El documento no está en estado de correcciones solicitadas",
                    "currentStatus", document.getStatus()
            ));
        }


        String originalFilename = file.getOriginalFilename();
        String finalFileName = UUID.randomUUID() + "_" + originalFilename;

        String modalityPath = document.getStudentModality()
                .getProgramDegreeModality()
                .getDegreeModality()
                .getName()
                .replaceAll("[^a-zA-Z0-9]", "_");

        String studentPath = student.getName() + student.getLastName() + "_" +
                student.getLastName() + "_" + studentModalityId;

        Path basePath = Paths.get(uploadDir, modalityPath, studentPath);
        Files.createDirectories(basePath);

        Path fullPath = basePath.resolve(finalFileName);
        Files.copy(file.getInputStream(), fullPath, StandardCopyOption.REPLACE_EXISTING);


        document.setFileName(originalFilename);
        document.setFilePath(fullPath.toString());
        document.setStatus(DocumentStatus.CORRECTION_RESUBMITTED);
        document.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(document);


        studentModality.setStatus(ModalityProcessStatus.CORRECTIONS_SUBMITTED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(DocumentStatus.CORRECTION_RESUBMITTED)
                        .changeDate(LocalDateTime.now())
                        .responsible(student)
                        .observations("Documento corregido reenviado por el estudiante dentro del plazo establecido")
                        .build()
        );


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.CORRECTIONS_SUBMITTED)
                        .changeDate(LocalDateTime.now())
                        .responsible(student)
                        .observations("Correcciones enviadas por el estudiante para revisión")
                        .build()
        );


        notificationEventPublisher.publish(
                new CorrectionResubmittedEvent(
                        studentModalityId,
                        documentId,
                        student.getId(),
                        document.getDocumentConfig().getDocumentName(),
                        student.getId()
                )
        );

        return ResponseEntity.ok(Map.of(
                "success", true,
                "message", "Documento corregido enviado exitosamente. Será revisado por el jurado correspondiente.",
                "documentId", documentId,
                "newStatus", document.getStatus()
        ));
    }

    @Transactional
    public ResponseEntity<?> approveCorrectedDocument(Long documentId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User reviewer = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentDocument document = studentDocumentRepository.findById(documentId)
                .orElseThrow(() -> new RuntimeException("Documento no encontrado"));

        StudentModality studentModality = document.getStudentModality();
        Long academicProgramId = studentModality.getAcademicProgram().getId();


        boolean authorized = false;
        ModalityProcessStatus newModalityStatus = null;
        DocumentStatus newDocumentStatus = null;

        if (studentModality.getStatus() == ModalityProcessStatus.CORRECTIONS_SUBMITTED) {

            if (document.getStatus() == DocumentStatus.CORRECTION_RESUBMITTED) {

                List<StudentDocumentStatusHistory> history =
                        documentHistoryRepository.findByStudentDocumentIdOrderByChangeDateDesc(documentId);

                boolean wasRequestedByProgramHead = history.stream()
                        .anyMatch(h -> h.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD);

                if (wasRequestedByProgramHead) {
                    authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                            reviewer.getId(), academicProgramId, ProgramRole.PROGRAM_HEAD);
                    newModalityStatus = ModalityProcessStatus.CORRECTIONS_APPROVED;
                    newDocumentStatus = DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW;
                } else {
                    authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                            reviewer.getId(), academicProgramId, ProgramRole.PROGRAM_CURRICULUM_COMMITTEE);
                    newModalityStatus = ModalityProcessStatus.CORRECTIONS_APPROVED;
                    newDocumentStatus = DocumentStatus.ACCEPTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW;
                }
            }
        }

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tienes permiso para aprobar este documento"
                    ));
        }


        document.setStatus(newDocumentStatus);
        document.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(document);


        studentModality.setCorrectionRequestDate(null);
        studentModality.setCorrectionDeadline(null);
        studentModality.setCorrectionReminderSent(null);


        if (newDocumentStatus == DocumentStatus.ACCEPTED_FOR_PROGRAM_HEAD_REVIEW) {
            studentModality.setStatus(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_HEAD);
        } else {
            studentModality.setStatus(ModalityProcessStatus.UNDER_REVIEW_PROGRAM_CURRICULUM_COMMITTEE);
        }

        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(newDocumentStatus)
                        .changeDate(LocalDateTime.now())
                        .responsible(reviewer)
                        .observations("Correcciones aprobadas. El documento cumple con los requisitos.")
                        .build()
        );

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(studentModality.getStatus())
                        .changeDate(LocalDateTime.now())
                        .responsible(reviewer)
                        .observations("Correcciones aprobadas. Continúa el proceso de revisión.")
                        .build()
        );


        notificationEventPublisher.publish(
                new CorrectionApprovedEvent(
                        studentModality.getId(),
                        documentId,
                        studentModality.getLeader().getId(),
                        document.getDocumentConfig().getDocumentName(),
                        reviewer.getId()
                )
        );

        return ResponseEntity.ok(Map.of(
                "success", true,
                "message", "Correcciones aprobadas exitosamente. La modalidad continúa su proceso normal.",
                "documentId", documentId,
                "newDocumentStatus", newDocumentStatus,
                "newModalityStatus", studentModality.getStatus()
        ));
    }

    @Transactional
    public ResponseEntity<?> rejectCorrectedDocumentFinal(Long documentId, String reason) {

        if (reason == null || reason.isBlank()) {
            return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "message", "Debe proporcionar el motivo del rechazo definitivo"
            ));
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User reviewer = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentDocument document = studentDocumentRepository.findById(documentId)
                .orElseThrow(() -> new RuntimeException("Documento no encontrado"));

        StudentModality studentModality = document.getStudentModality();
        Long academicProgramId = studentModality.getAcademicProgram().getId();


        boolean authorized = false;
        if (studentModality.getStatus() == ModalityProcessStatus.CORRECTIONS_SUBMITTED) {
            List<StudentDocumentStatusHistory> history =
                    documentHistoryRepository.findByStudentDocumentIdOrderByChangeDateDesc(documentId);

            boolean wasRequestedByProgramHead = history.stream()
                    .anyMatch(h -> h.getStatus() == DocumentStatus.CORRECTIONS_REQUESTED_BY_PROGRAM_HEAD);

            if (wasRequestedByProgramHead) {
                authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        reviewer.getId(), academicProgramId, ProgramRole.PROGRAM_HEAD);
            } else {
                authorized = programAuthorityRepository.existsByUser_IdAndAcademicProgram_IdAndRole(
                        reviewer.getId(), academicProgramId, ProgramRole.PROGRAM_CURRICULUM_COMMITTEE);
            }
        }

        if (!authorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tienes permiso para rechazar este documento"
                    ));
        }


        document.setStatus(DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW);
        document.setNotes(reason);
        document.setUploadDate(LocalDateTime.now());
        studentDocumentRepository.save(document);


        studentModality.setStatus(ModalityProcessStatus.CORRECTIONS_REJECTED_FINAL);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        documentHistoryRepository.save(
                StudentDocumentStatusHistory.builder()
                        .studentDocument(document)
                        .status(DocumentStatus.REJECTED_FOR_PROGRAM_CURRICULUM_COMMITTEE_REVIEW)
                        .changeDate(LocalDateTime.now())
                        .responsible(reviewer)
                        .observations("Rechazo definitivo: " + reason)
                        .build()
        );

        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.CORRECTIONS_REJECTED_FINAL)
                        .changeDate(LocalDateTime.now())
                        .responsible(reviewer)
                        .observations("Modalidad cancelada por rechazo definitivo de correcciones. Motivo: " + reason)
                        .build()
        );


        notificationEventPublisher.publish(
                new CorrectionRejectedFinalEvent(
                        studentModality.getId(),
                        documentId,
                        studentModality.getLeader().getId(),
                        document.getDocumentConfig().getDocumentName(),
                        reason,
                        reviewer.getId()
                )
        );

        return ResponseEntity.ok(Map.of(
                "success", true,
                "message", "Correcciones rechazadas definitivamente. La modalidad ha sido cancelada.",
                "documentId", documentId,
                "finalStatus", ModalityProcessStatus.CORRECTIONS_REJECTED_FINAL
        ));
    }


    public ResponseEntity<?> getCorrectionDeadlineStatus(Long studentModalityId) {

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));

        // Validar que el usuario sea miembro activo de la modalidad o un revisor autorizado
        boolean isStudent = studentModalityMemberRepository.isActiveMember(
                studentModalityId,
                user.getId()
        );
        boolean isAuthorizedReviewer = programAuthorityRepository.existsByUser_IdAndAcademicProgram_Id(
                user.getId(),
                studentModality.getAcademicProgram().getId()
        );

        if (!isStudent && !isAuthorizedReviewer) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tienes permiso para consultar esta información"
                    ));
        }


        if (studentModality.getStatus() != ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_HEAD &&
                studentModality.getStatus() != ModalityProcessStatus.CORRECTIONS_REQUESTED_PROGRAM_CURRICULUM_COMMITTEE) {
            return ResponseEntity.ok(Map.of(
                    "hasCorrectionRequest", false,
                    "currentStatus", studentModality.getStatus(),
                    "message", "No hay correcciones solicitadas actualmente"
            ));
        }


        LocalDateTime now = LocalDateTime.now();
        long daysRemaining = 0;
        boolean isExpired = false;

        if (studentModality.getCorrectionDeadline() != null) {
            daysRemaining = ChronoUnit.DAYS.between(now, studentModality.getCorrectionDeadline());
            isExpired = daysRemaining < 0;
        }

        return ResponseEntity.ok(Map.of(
                "hasCorrectionRequest", true,
                "currentStatus", studentModality.getStatus(),
                "correctionRequestDate", studentModality.getCorrectionRequestDate(),
                "correctionDeadline", studentModality.getCorrectionDeadline(),
                "daysRemaining", Math.max(0, daysRemaining),
                "isExpired", isExpired,
                "reminderSent", studentModality.getCorrectionReminderSent() != null ? studentModality.getCorrectionReminderSent() : false
        ));
    }


    @Transactional
    public ResponseEntity<?> closeModalityByCommittee(Long studentModalityId, String reason) {


        if (reason == null || reason.isBlank()) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "Debe proporcionar el motivo del cierre de la modalidad"
                    )
            );
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth.getName();

        User committeeMember = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        StudentModality studentModality = studentModalityRepository.findById(studentModalityId)
                .orElseThrow(() -> new RuntimeException("Modalidad no encontrada"));


        Long academicProgramId = studentModality.getAcademicProgram().getId();

        boolean isAuthorized = programAuthorityRepository
                .existsByUser_IdAndAcademicProgram_IdAndRole(
                        committeeMember.getId(),
                        academicProgramId,
                        ProgramRole.PROGRAM_CURRICULUM_COMMITTEE
                );

        if (!isAuthorized) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(Map.of(
                            "success", false,
                            "message", "No tiene permiso para cerrar modalidades de este programa académico. Debe ser miembro del comité de currículo del programa."
                    ));
        }


        if (studentModality.getStatus() == ModalityProcessStatus.MODALITY_CLOSED) {
            return ResponseEntity.badRequest().body(
                    Map.of(
                            "success", false,
                            "message", "La modalidad ya se encuentra cerrada",
                            "currentStatus", studentModality.getStatus()
                    )
            );
        }


        ModalityProcessStatus previousStatus = studentModality.getStatus();


        studentModality.setStatus(ModalityProcessStatus.MODALITY_CLOSED);
        studentModality.setUpdatedAt(LocalDateTime.now());
        studentModalityRepository.save(studentModality);


        historyRepository.save(
                ModalityProcessStatusHistory.builder()
                        .studentModality(studentModality)
                        .status(ModalityProcessStatus.MODALITY_CLOSED)
                        .changeDate(LocalDateTime.now())
                        .responsible(committeeMember)
                        .observations(String.format(
                                "Modalidad cerrada por el comité de currículo del programa. Estado anterior: %s. Motivo: %s",
                                previousStatus,
                                reason
                        ))
                        .build()
        );


        notificationEventPublisher.publish(
                new ModalityClosedByCommitteeEvent(
                        studentModality.getId(),
                        studentModality.getLeader().getId(),
                        reason,
                        committeeMember.getId()
                )
        );

        return ResponseEntity.ok(
                Map.of(
                        "success", true,
                        "studentModalityId", studentModalityId,
                        "previousStatus", previousStatus,
                        "newStatus", ModalityProcessStatus.MODALITY_CLOSED,
                        "closedBy", committeeMember.getName() + " " + committeeMember.getLastName(),
                        "reason", reason,
                        "message", "Modalidad cerrada exitosamente. El estudiante ha sido notificado por correo electrónico."
                )
        );
    }

}
